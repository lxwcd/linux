**网络安全基础学习**


# 信息安全防护目标
> [Information security](https://en.wikipedia.org/wiki/Information_security#Integrity)

Alice 要发送给信息给 Bob
1. 对于 Alice 来说要确保的有：
- 完整性（Integrity）：数据能完整的发送给 Bob，不丢失，不被篡改
- 保密性（Confidentiality）：数据发送的过程能保密，不被其他人看到
- 可控性（Controlablity）：对数据的传播和内容有控制能力
  如可以设置对方对数据的操作权限，不能超过权限使用
- 不可抵赖性（Non-repudiation）：用户无法否认其行为

1. 对于 Bob 来说，要确保的有：
- 真实性（Authenticity）：对数据来源进行判断，识别来源的信息
- 完整性（Integrity）：确保数据未被修改
- 可用性（Usability）：可以合法的使用数据，不会被拒绝


# 安全防护环节
## 物理安全（Physical security）
- 机房设备环境

## 系统安全（System security）
- 操作系统

## 应用安全（Application security）
- 网络服务
- 应用程序

## 网络安全（Network security）
- 网络访问控制，防火墙规则设置

## 数据安全（Data security）
- 数据加密
- 数据备份

## 管理安全（Manage security）
- 保障性规范


# 常见的安全攻击
> [STRIDE (security)](https://en.wikipedia.org/wiki/STRIDE_(security))

# 常用的安全技术
## 认证

## 授权

## 审计

## 安全通信


# 加密算法

## 对称加密算法
> [Symmetric key alogrithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm)

- Alice 和 Bob 使用一个双方都知道的密钥加密数据
- 例如电视电影中常见的 Alice 和 Bob 约定使用某一本书的内容加密，第几页的第几行的第几列，三个数字找到一个字符

常见的有：
- DES
- 3DES
- IDEA
- AES
- RC4

  
优点：
- 加密和解密密钥相同，效率高
  
缺点：
- 发送方很难安全传输密钥：计算机通信中，如需临时进行一次通信，怎么能安全的将密钥告诉对方？
- 接收方无法确认来源：一方收到密钥后怎么确认来源的可靠性，如果是中间人伪造的密钥呢？


## 非对称加密算法
> [Public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)

- 也叫公钥加密算法
- 利用一对密钥进行加密和解密
- 密钥成对出现，有公钥（public key）和私钥（secret key）
- 公钥加密的数据只有对应的私钥能解密
- 私钥要保密，只有自己持有，公钥可以公开
- Alice 用 Bob 的公钥加密数据，只有 Bob 能用自己的私钥解密，即使数据被截获也无法看到内容


特点：
- 如果确定了对方的公钥没问题，可以保证数据安全性，对方公钥加密的数据只有对方私钥能解密


不足：
- 算法复杂，不适合加密大数据，效率低，适合加密较小的数据
- 可能遇到中间人攻击（(Man-in-the-middle attack)[https://en.wikipedia.org/wiki/Man-in-the-middle_attack] ）
如有中间人冒充 Bob 发给 Alice 自己的公钥，获取从 Alice 得到的数据后可以用自己的私钥解密


常见算法：
- RSA
- [Digital Signature Algorithm (DSA)](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm)
- [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)
比 RSA 使用更小的密钥，更高的安全性
- [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) 
- [ED25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519)

# 单向哈希算法
> [Cryptographic hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
> [Hash function](https://en.wikipedia.org/wiki/Hash_function)

- h=hash(m)
- one-way function，单向性，不能根据最终的哈希值 h，得到原始的数据的内容
- 大多数是任意长度输入（m），固定长度输出（h）
- 两组不同的数据 m1 和 m2，其得到的哈希值相差很大
- 相同的数据得到的哈希值相同
- 哈希运算的结果叫 message digest，即消息摘要


## 应用场景
- 确认数据的完整性
根据哈希算法的特点，可以传输时用某个哈希算法对数据内容做哈希运算得到一个摘要（message digest），
接收方收到数据后，用相同的哈希算法对数据做哈希运算，如果得到的摘要和发送方的摘要相同，则表示数据未被篡改

如下载某个软件时，官方提供安装包和 checksum 文件，该 checksum 文件中即为该文件的摘要，
用户下载文件后用官方指定的哈希算法对文件进行哈希运算，如果得到的摘要信息相同，则表示文件未被修改

如下载 [MySQL](https://dev.mysql.com/downloads/repo/apt/)，官方提供的软件包的摘要和算法如下：
```
MD5: 3f16076cf125a07675eb5f9ef080f1f7 
```
因此下载该包后可以用 MD5 哈希算法对文件进行哈希运算，得到的摘要和官方提供的相同则文件没问题

![](img/2023-05-20-11-32-29.png)


## 常用的哈希算法有
> [Secure Hash Algorithms](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms)

- MD5
- SHA-256
- SHA-512


# 指纹（Fingerprint）
> [Fingerprint (computing)](https://en.wikipedia.org/wiki/Fingerprint_(computing)) 

根据维基百科中的说法，指纹和哈希算法得到摘要的原理类似，指纹函数可以看作高性能的哈希函数
指纹函数也是可以将数据运算后得到唯一的指纹，该指纹字符串很短，特点和摘要很像
可以用于跟踪一个文件是否被修改过等，指纹字符很短，很多场景使用比哈希运算更适合

上述说法是否准确不确定，有些地方将指纹和哈希看作相同的，
[Hash function](https://en.wikipedia.org/wiki/Hash_function) 中指明两者有区别，但未说明具体区别


# 数字签名
> [What are digital signatures?](https://www.docusign.com/how-it-works/electronic-signature/digital-signature/digital-signature-faq)
> [Digital signature](https://en.wikipedia.org/wiki/Digital_signature)

- 数字签名可以让接受数据一方确认数据的完整性和来源
- 数字签名不对数据加密
- 例如某个官方提供一个软件包，用户下载该软件包时可以利用数字签名确保文件未被篡改，来源可靠
如下载 [MySQL](https://dev.mysql.com/downloads/repo/apt/)，官方提供的软件包的摘要和算法如下：
官方提供数字签名验证方法：[2.1.4.2 Signature Checking Using GnuPG](https://dev.mysql.com/doc/refman/8.0/en/checking-gpg-signature.html) 


数字签名过程：
- 发送方
1. 将数据用哈希算法计算得到一个摘要（message digest）
2. 将得到的摘要用自己的私钥加密
3. 要传输的数据 + 加密的摘要 ==> 数字签名的文档（digital singed document）

- 接收方
1. 用发送方的公钥解密被加密的摘要，得到原始数据的摘要
2. 用相同的哈希算法对收到的数据计算得到一个收到数据的摘要
3. 比对解密后的摘要和自己计算的摘要，如相同，则表示数据未被篡改


特点：
1. 哈希算法对比摘要保证数据的完整性
2. 公私钥匙加密解密确认来源
   

不足：
1. 接受方需要通过可靠的方式确保公钥是加密方的公钥而非中间人的公钥

# CA 
> [Issuing a certificate](https://en.wikipedia.org/wiki/Certificate_authority#Issuing_a_certificate)

数字签名有个问题是无法确认公钥的可靠性，因此需要一个权威的机构来认证，让用户相信公钥的可靠性

CA（Certificate authority）是权威的颁发数字证书的机构
Windows 系统上内置受信任的根证书颁发机构，这些权威机构的公钥和所用的签名算法是公开的
根 CA 下还有很多下级 CA，申请数字证书时可能从某一级 CA 申请颁发，该证书中会带有其上级 CA 的证书，
直到根 CA 证书，一级一级验证


## 向 CA 机构申请证书的过程
> [X.509](https://en.wikipedia.org/wiki/X.509#Structure_of_a_certificate)
> [Public key certificate](https://en.wikipedia.org/wiki/Public_key_certificate)


1. 向 CA 机构提供自己的信息：自己的机构名等信息（类似办理身份证），自己的公钥以及公钥算法
2. CA 机构验证提交的信息后，加上颁发机构信息，证书的有效期，对该证书要使用的哈希算法和签名算法
3. 上面内容组成数字证书的 body 部分，该内容不加密，公开的

4. CA 利用证书中写明的哈希算法对 body 部分做哈希运算，得到该内容的摘要（message digest）
5. CA 利用证书中写明的签名算法对上面得到的摘要进行数字签名，即用自己的私钥用签名算法对摘要加密

6. 如果 CA 颁发机构不是根证书颁发机构，该证书中还要携带其上级 CA 给自己颁发的证书，
以及上级证书的证书，直到最上面的根 CA 的颁发证书，而根 CA 的证书是操作系统中自带的



### 证书的内容
> [4. Certificate and Certificate Extensions Profile](https://www.rfc-editor.org/rfc/rfc5280#section-4)

X.509 v3 certificate 有三部分
```
Certificate  ::=  SEQUENCE  {
        tbsCertificate       TBSCertificate,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  }
```
1. TBSCertificate
即 To-Be-Signed Certificate，需要签名的证书 body 部分，该部分内容公开，需要进行数字签名

- serial number
证书的一个序列号，唯一标识

- subject
证书持有者的信息，组织名，地址等，如
```
CN = *.wikipedia.org
O = Wikimedia Foundation, Inc.
L = San Francisco
ST = California
C = US
```

- issuer
颁发证书单位的信息，如：
```
CN = DigiCert TLS Hybrid ECC SHA384 2020 CA1
O = DigiCert Inc
C = US
```

- validity
证书的有效期，包括 not before 和 not after 两个时间，即证书起始和失效时间

- Subject Public Key Info
证书持有者的公钥信息
  - Public Key Algorithm
  公钥解密时所用是算法，即非对称加密算法，如：
  ```
  Elliptic Curve Public Key
  ```
  - Subject Public Key
  证书持有者的公钥

- AlgorithmIdentifier
和 Certificate Signature Algorithm 内容要相同

- Extensions (optional)
可有可无的一段


2. Certificate Signature Algorithm
证书签名算法，包含两个算法
一个是 CA 对证书内容（body）部分利用哈希算法进行运算得到一个摘要的算法
一个是 CA 对上面摘要进行数字签名（公私钥非对称加密解密算法），即 CA 用自己的私钥加密
如下面内容表示证书的内容用 SHA-384 哈希算法运算，再将得到的摘要用 ECDSA 算法进行签名
```
X9.62 ECDSA Signature with SHA-384
```

3. Certificate Signature Value
证书数字签名的结果，该部分不是证书 body 的部分，证书的 body 部分未加密，公开的
用户根据证书的内容知道证书数字签名的算法，利用相同算法和 CA 的公钥对数字签名的值解密
得到摘要信息，再根据证书的内容，用相同的哈希算法对证书内容进行哈希运算
最好比对哈希运算的结果和数字签名解密后的结果（哈希运算不可逆）



## <font color=red>问题：Fingerprints</font>
用 google chrome 进入如维基百科网页时，点击网页 url 左侧的小锁，查看证书时发现最后有个指纹信息

> Fingerprints
> SHA-256 Fingerprint	95 A6 25 3C F5 BA 9E 9C 79 C9 E1 66 74 AE 68 DA
> 28 99 75 43 93 FF 3F AA 5C 4B D5 10 B3 8D 95 A7
> SHA-1 Fingerprint	91 D4 DD DD 2F F9 18 E0 19 07 D8 6B C7 54 54 F1
> 1A 8F 2C DC

网上看到一些说法是，这段指纹不是证书的内容，是最后 CA 对整个证书生成的指纹，但这样的用处是什么？
如果证书被篡改，那指纹也可以重新生成？没有其他地方告知该证书的真正指纹应是多少？


## 用户验证数字证书的过程
1. 用户根据证书的 body 部分得知数字签名的算法，用相同的算法和 CA 的公钥解密签名数值，得到摘要信息
2. 根据证书 body 部分的哈希算法，用相同的算法对 body 进行哈希运算，得到一个摘要值
3. 比对自己计算得到的摘要和数字签名解密后得到的摘要值，相同则证书可信


## 证书文件名后缀
> [Certificate filename extensions](https://en.wikipedia.org/wiki/X.509#Certificate_filename_extensions)

> .pem – (Privacy-enhanced Electronic Mail) Base64 encoded DER certificate, 
> enclosed between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----
>
> .cer, .crt, .der – usually in binary DER form, but Base64-encoded certificates are common too (see .pem above)
>
> .p7b, .p7c – PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)
>
> .p12 – PKCS#12, may contain certificate(s) (public) and private keys (password protected)
>
> .pfx – PFX, predecessor of PKCS#12 (usually contains data in PKCS#12 format, e.g., with PFX files generated in IIS)


# 多种算法综合运用
- Alice 发送数据给 Bob
## Pb{Sa[hash(data)]+data}
1. Alice 将数据用哈希算法加密得到摘要
2. Alice 将摘要用自己的私钥加密进行数字签名
3. Alice 将数字签名和数据用 Bob 的公钥加密

## key{Sa[hash(data)]+data}+Pb(key)
1. Alice 将数据用哈希算法加密得到摘要
2. Alice 将摘要和数据一起用自己的私钥加密
3. Alice 用一个对称的密钥加密第二部的数据得到密文
4. Alice 用 Bob 的公钥加密第三步的对称密钥


# IKE 互联网密钥交换协议
> [IKE](https://en.wikipedia.org/wiki/Internet_Key_Exchange#IKEv1_phases)

> In computing, Internet Key Exchange (IKE, sometimes IKEv1 or IKEv2, depending on version)
> is the protocol used to set up a security association (SA) in the IPsec protocol suite.


## Diffie–Hellman key exchange 
> [Diffie–Hellman key exchange](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange)


- 通信双方在公共信道中安全交换密钥的一种安全方法

> In the Diffie–Hellman key exchange scheme, each party generates a public/private key pair
> and distributes the public key. 
> After obtaining an authentic copy of each other's public keys, 
> Alice and Bob can compute a shared secret offline. 
> The shared secret can be used, for instance, as the key for a symmetric cipher.


# PKI 公共密钥加密体系
> [Public key infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure)

> A public key infrastructure (PKI) is a set of roles, policies, hardware, 
> software and procedures needed to create, manage, distribute, use, 
> store and revoke digital certificates and manage public-key encryption. 


# 安全协议 SSL/TLS
> [What is an SSL Certificate?](https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https)
> [What is SSL?](https://www.ssl.com/faqs/faq-what-is-ssl/)

- SSL 和 TLS 都是安全协议，保证数据在网络中安全传输
- TLS 是 SSL 的升级，当前主要用 TLS
- TLS 协议在应用层和运输层之间位置

原来的 http 是不安全的明文传输协议，后来的 https 即为 http 和 TLS 的组合，对数据加密，更安全


# ssh handshake
> [SSH Handshake Explained](https://goteleport.com/blog/ssh-handshake-explained/)
> [SSH Handshake](https://yabhinav.github.io/security/openssh-handshake-overview/)


1. SSH protocol version exchange
客户端和服务端双方交换 SSH 版本信息
不同的版本有些功能有差异，因此需要确认双方版本

2. Key Exchange Initialization

- 双方发送 `SSH_MSG_KEX_INIT` 消息协商使用的加密算法
  该消息中携带自己支持的加密算法列表，以及算法的优先级
  为了后面使用算法加密能达成一致，使用双方都支持的算法

3. Key Exchange 
交换密钥，如用 Elliptic Curve Diffie-Hellman (ECDH) 方法交换密钥

- 客户端生成一对临时的公私钥对，该密钥对仅在此次会话中短暂有效，不会存在文件中保存下来，因此更安全
- 客户端将其临时公钥发送给服务端，如发送 `SSH_MSG_KEX_ECDH_INIT` message
- 服务端监听 `SSH_MSG_KEX_ECDH_INIT` message，一旦接受到该消息，
  服务端也生成一对临时的公私钥对，
  服务端利用客户端的公钥和自己的生成的临时的密钥对生成一个共享的密钥 `k`（该过程通过 Diffie-Hellman 算法得到）,生成的该共享密钥为对称密钥，用于后面的一些通信
- 




- 客户端第一次连接服务端时会显示服务端的指纹，指明了生成指纹所使用的公钥文件
以及加密算法，不同的客户端连接服务器时使用的算法可能不同

如服务端为 ubuntu20.04，其 `/etc/ssh` 目录中有几种不同算法的公钥：
```bash
[18:59:15 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```
- `rsa` 和  `ecdsa` 分别对应不同的密钥交换算法


客户端第一次连接，如 rocky8 连接，会提示指纹信息：
```bash
[root@rocky8-3 .ssh]$ ssh 192.168.137.17
The authenticity of host '192.168.137.17 (192.168.137.17)' can't be established.
ECDSA key fingerprint is SHA256:iBJIDP0FkveLmB549s75m3T7qfYU4nuNUKLeJqwRj2M.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
从提示可以看出使用的公钥为 `ssh_host_ecdsa_key.pub`，对该公钥进行数字前面的单项哈希算法为 `SHA256`

而客户端 ubuntu22.04 来连接服务器时，提示为：
```bash
[root@ubunut22:~]$ ssh  192.168.137.17
The authenticity of host '192.168.137.17 (192.168.137.17)' can't be established.
ED25519 key fingerprint is SHA256:gLez30G4gynTfEWJe7kvn3I0w5x8a18+/wvDQorzCEk.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
从提示可以看出使用的公钥为 `ssh_host_ed25519_key.pub`，对该公钥进行数字前面的单项哈希算法为 `SHA256`
因此两者的指纹不同

- 验证指纹是否正确
此时客户端需要确认指纹是否正确从而确认服务端的是相连接的服务端而非其他中间人
服务端可以在自己主机上查看生成的指纹，从而进行比对（单项哈希算法生成的指纹不可逆的）

1）服务端可以通过连自己查看指纹，但这里默认的公钥文件为 `ssh_host_ecdsa_key.pub`
```bash
[19:23:41 root@ubuntu2004 /etc/ssh]#ssh 127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:iB
```

```bash
[19:34:49 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```

2）通过 ssh-keygen 生成指纹进行比对
`ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]`
`-l` 表示显示公钥文件的指纹
`-E` 显示用于数字签名的单向哈希算法，可选的有 `sha256` 和 `md5`，默认为 `sha256`
`-f` 指定公钥文件

```bash
[19:37:06 root@ubuntu2004 /etc/ssh]#ssh-keygen -l -E "sha256" -f ssh_host_ed25519_key.pub
256 SHA256:gLez30G4gynTfEWJe7kvn3I0w5x8a18+/wvDQorzCEk root@cdqz-KPL-W0X (ED25519)
```

- 客户端确认指纹后输入 `yes` 则将服务端的公钥文件，如 `ssh_host_ed25519_key.pub` 
  下载到自己家目录的 `$HOME/.ssh/known_hosts` 文件中，以后再次连接时就不需要确认指纹 


如果不想输入 yes 来确认指纹，修改客户端配置文件


```
The reason you cannot use `sha256sum` to calculate the fingerprint of `ssh_host_ed25519_key.pub` is that the fingerprint is not simply a hash of the public key file. It is actually a specific representation of the public key that includes a hash of the key and some other metadata.

The fingerprint of an SSH public key is calculated using a specific algorithm that takes into account the type of key, the hash algorithm used to generate the key, and the actual public key data. For example, the fingerprint of an Ed25519 public key is calculated using the SHA-256 hash algorithm, but it includes additional information such as the key type and length.

To calculate the fingerprint of an SSH public key, you should use a tool that is specifically designed for this purpose, such as `ssh-keygen` or `openssl`. These tools will generate the correct representation of the public key and calculate the fingerprint using the appropriate algorithm.
```




## 安装 ssh 服务端

## 查看 ssh 配置文件
### Ubuntu 查看



