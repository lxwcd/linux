**网络安全基础学习**


# 信息安全防护目标
> [Information security](https://en.wikipedia.org/wiki/Information_security#Integrity)

Alice 要发送给信息给 Bob
1. 对于 Alice 来说要确保的有：
- 完整性（Integrity）：数据能完整的发送给 Bob，不丢失，不被篡改
- 保密性（Confidentiality）：数据发送的过程能保密，不被其他人看到
- 可控性（Controlablity）：对数据的传播和内容有控制能力
  如可以设置对方对数据的操作权限，不能超过权限使用
- 不可抵赖性（Non-repudiation）：用户无法否认其行为

1. 对于 Bob 来说，要确保的有：
- 真实性（Authenticity）：对数据来源进行判断，识别来源的信息
- 完整性（Integrity）：确保数据未被修改
- 可用性（Usability）：可以合法的使用数据，不会被拒绝
- 不可抵赖性（Non-repudiation）：Alice 无法否认其行为


# 安全防护环节
## 物理安全（Physical security）
- 机房设备环境

## 系统安全（System security）
- 操作系统

## 应用安全（Application security）
- 网络服务
- 应用程序

## 网络安全（Network security）
- 网络访问控制，防火墙规则设置

## 数据安全（Data security）
- 数据加密
- 数据备份

## 管理安全（Manage security）
- 保障性规范


# 常见的安全攻击
> [STRIDE (security)](https://en.wikipedia.org/wiki/STRIDE_(security))


# 常用的安全技术
## 认证（Authentication）
> [What is Authentication? Different Types of Authentication](https://blog.miniorange.com/different-types-of-authentication-methods-for-security/)

1. Password-based authentication
2. Biometric authentication
3. Multi-factor authentication
4. Certificate-based authentication
5. Token-based authentication
6. Kerberos authentication
7. Single Sign-On (SSO)
8. SAML-based authentication
9. OpenID-based authentication
10. OAuth-based authentication

- Authentication 决定用户是否能访问某个资源

## 授权（Authorization）
> [Authentication vs. Authorization](https://www.okta.com/identity-101/authentication-vs-authorization/)


- Authorization 决定用户访问资源时具有哪些权限，如可能只读，或者部分文件不能访问等

## 审计（Audit）
> [What Is a Security Audit? The Basics You Need to Get Started](https://www.auditboard.com/blog/what-is-security-audit/)


## 安全通信（Secure communication）
> [Secure communication](https://en.wikipedia.org/wiki/Secure_communication)



# 加密算法（Encrption algorithm）
> [5 Common Encryption Algorithms and the Unbreakables of the Future](https://www.arcserve.com/blog/5-common-encryption-algorithms-and-unbreakables-future)


- 传统的加密方法，例如 Alice 和 Bob 约定使用某一本书的内容加密，第几页的第几行的第几列，三个数字找到一个字符

## 对称加密算法
> [Symmetric key alogrithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm)

- Alice 和 Bob 使用一个双方都知道的密钥加密数据

常见的有：
- DES
- 3DES
- IDEA
- AES
- RC4

  
优点：
- 加密和解密密钥相同，效率高
  
缺点：
- 发送方很难安全传输密钥：计算机通信中，如需临时进行一次通信，怎么能安全的将密钥告诉对方？
- 接收方无法确认来源：一方收到密钥后怎么确认来源的可靠性，如果是中间人伪造的密钥呢？


## 非对称加密算法
> [Public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)

- 也叫公钥加密算法
- 利用一对密钥进行加密和解密
- 密钥成对出现，有公钥（public key）和私钥（secret key）
- 公钥加密的数据只有对应的私钥能解密
- 私钥要保密，只有自己持有，公钥可以公开
- Alice 用 Bob 的公钥加密数据，只有 Bob 能用自己的私钥解密，即使数据被截获也无法看到内容


特点：
- 如果确定了对方的公钥没问题，可以保证数据安全性，对方公钥加密的数据只有对方私钥能解密


不足：
- 算法复杂，不适合加密大数据，效率低，适合加密较小的数据
- 可能遇到中间人攻击（(Man-in-the-middle attack)[https://en.wikipedia.org/wiki/Man-in-the-middle_attack] ）
如有中间人冒充 Bob 发给 Alice 自己的公钥，获取从 Alice 得到的数据后可以用自己的私钥解密
根本原因是 Alice 无法确认收到的公钥是否真的是 Bob 的


常见算法：
- RSA
- [Digital Signature Algorithm (DSA)](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm)
- [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)
比 RSA 使用更小的密钥，更高的安全性
- [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) 
- [ED25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519)

## 单向哈希算法
> [Cryptographic hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
> [Hash function](https://en.wikipedia.org/wiki/Hash_function)

- h=hash(m)
- one-way function，单向性，不能根据最终的哈希值 h，得到原始的数据的内容
- 大多数是任意长度输入（m），固定长度输出（h）
- 两组不同的数据 m1 和 m2，即使内容相差很小，其得到的哈希值相差很大，即雪崩效应
- 相同的数据得到的哈希值相同
- 哈希运算的结果叫 message digest，即消息摘要
- 信息安全中使用的哈希函数是加密的哈希函数（cryptographic hash function），非普通的哈希函数




### 应用场景
- 确认数据的完整性
根据哈希算法的特点，可以传输时用某个哈希算法对数据内容做哈希运算得到一个摘要（message digest），
接收方收到数据后，用相同的哈希算法对数据做哈希运算，如果得到的摘要和发送方的摘要相同，则表示数据未被篡改

如下载某个软件时，官方提供安装包和 checksum 文件，该 checksum 文件中即为该文件的摘要，
用户下载文件后用官方指定的哈希算法对文件进行哈希运算，如果得到的摘要信息相同，则表示文件未被修改

如下载 [MySQL](https://dev.mysql.com/downloads/repo/apt/)，官方提供的软件包的摘要和算法如下：
```
MD5: 3f16076cf125a07675eb5f9ef080f1f7 
```
因此下载该包后可以用 MD5 哈希算法对文件进行哈希运算，得到的摘要和官方提供的相同则文件没问题

![](img/2023-05-20-11-32-29.png)


### 常用的哈希算法有
> [Secure Hash Algorithms](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms)

- MD5
message-digest algorithm，很常用，很多软件用 MD5 算法来得到一个 checksum 来验证数据的 Integrity
该算法已经被验证不安全，因此只能用于一些非加密的目的使用
- SHA-256
属于 Secure Hash Algorithm 2，其摘要的长度为 256 bits
- SHA-512
属于 Secure Hash Algorithm 2，其摘要的长度为 512 bits


# 指纹（Fingerprint）
> [Fingerprint (computing)](https://en.wikipedia.org/wiki/Fingerprint_(computing)) 

根据维基百科中的说法，指纹和哈希算法得到摘要的原理类似，指纹函数可以看作高性能的哈希函数
指纹函数也是可以将数据运算后得到唯一的指纹，该指纹字符串很短，特点和摘要很像
可以用于跟踪一个文件是否被修改过等，指纹字符很短，很多场景使用比哈希运算更适合

上述说法是否准确不确定，有些地方将指纹和哈希看作相同的，
[Hash function](https://en.wikipedia.org/wiki/Hash_function) 中指明两者有区别，但未说明具体区别


# 数字签名
> [What are digital signatures?](https://www.docusign.com/how-it-works/electronic-signature/digital-signature/digital-signature-faq)
> [Digital signature](https://en.wikipedia.org/wiki/Digital_signature)

- 数字签名可以让接受数据一方确认数据的完整性和来源
- 数字签名不对数据加密
- 例如某个官方提供一个软件包，用户下载该软件包时可以利用数字签名确保文件未被篡改，来源可靠
如下载 [MySQL](https://dev.mysql.com/downloads/repo/apt/)，官方提供的软件包的摘要和算法如下：
官方提供数字签名验证方法：[2.1.4.2 Signature Checking Using GnuPG](https://dev.mysql.com/doc/refman/8.0/en/checking-gpg-signature.html) 


数字签名过程：
- 发送方
1. 将数据用哈希算法计算得到一个摘要（message digest）
2. 将得到的摘要用自己的私钥加密
3. 要传输的数据 + 加密的摘要 ==> 数字签名的文档（digital singed document）

- 接收方
1. 用发送方的公钥解密被加密的摘要，得到原始数据的摘要
2. 用相同的哈希算法对收到的数据计算得到一个收到数据的摘要
3. 比对解密后的摘要和自己计算的摘要，如相同，则表示数据未被篡改


特点：
1. 哈希算法对比摘要保证数据的完整性
2. 公私钥匙加密解密确认来源
   

不足：
1. 接受方需要通过可靠的方式确保公钥是加密方的公钥而非中间人的公钥


# CA 颁发证书
> [Issuing a certificate](https://en.wikipedia.org/wiki/Certificate_authority#Issuing_a_certificate)

数字签名有个问题是无法确认公钥的可靠性，因此需要一个权威的机构来认证，让用户相信公钥的可靠性

CA（Certificate authority）是权威的颁发数字证书的机构
Windows 系统上内置受信任的根证书颁发机构，这些权威机构的公钥和所用的签名算法是公开的
根 CA 下还有很多下级 CA，申请数字证书时可能从某一级 CA 申请颁发，该证书中会带有其上级 CA 的证书，
直到根 CA 证书，一级一级验证


## 向 CA 机构申请证书的过程
> [X.509](https://en.wikipedia.org/wiki/X.509#Structure_of_a_certificate)
> [Public key certificate](https://en.wikipedia.org/wiki/Public_key_certificate)


1. 向 CA 机构提供自己的信息：自己的机构名等信息（类似办理身份证），自己的公钥以及公钥算法
2. CA 机构验证提交的信息后，加上颁发机构信息，证书的有效期，对该证书要使用的哈希算法和签名算法
3. 上面内容组成数字证书的 body 部分，该内容不加密，公开的

4. CA 利用证书中写明的哈希算法对 body 部分做哈希运算，得到该内容的摘要（message digest）
5. CA 利用证书中写明的签名算法对上面得到的摘要进行数字签名，即用自己的私钥用签名算法对摘要加密

6. 如果 CA 颁发机构不是根证书颁发机构，该证书中还要携带其上级 CA 给自己颁发的证书，
以及上级证书的证书，直到最上面的根 CA 的颁发证书，而根 CA 的证书是操作系统中自带的



## CA 颁发的证书内容
> [4. Certificate and Certificate Extensions Profile](https://www.rfc-editor.org/rfc/rfc5280#section-4)

X.509 v3 certificate 有三部分
```
Certificate  ::=  SEQUENCE  {
        tbsCertificate       TBSCertificate,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  }
```
1. TBSCertificate
即 To-Be-Signed Certificate，需要签名的证书 body 部分，该部分内容公开，需要进行数字签名

- serial number
证书的一个序列号，唯一标识

- subject
证书持有者的信息，组织名，地址等，如
```
CN = *.wikipedia.org
O = Wikimedia Foundation, Inc.
L = San Francisco
ST = California
C = US
```

- issuer
颁发证书单位的信息，如：
```
CN = DigiCert TLS Hybrid ECC SHA384 2020 CA1
O = DigiCert Inc
C = US
```

- validity
证书的有效期，包括 not before 和 not after 两个时间，即证书起始和失效时间

- Subject Public Key Info
证书持有者的公钥信息
  - Public Key Algorithm
  公钥解密时所用是算法，即非对称加密算法，如：
  ```
  Elliptic Curve Public Key
  ```
  - Subject Public Key
  证书持有者的公钥

- AlgorithmIdentifier
和 Certificate Signature Algorithm 内容要相同

- Extensions (optional)
可有可无的一段


2. Certificate Signature Algorithm
证书签名算法，包含两个算法
一个是 CA 对证书内容（body）部分利用哈希算法进行运算得到一个摘要的算法
一个是 CA 对上面摘要进行数字签名（公私钥非对称加密解密算法），即 CA 用自己的私钥加密
如下面内容表示证书的内容用 SHA-384 哈希算法运算，再将得到的摘要用 ECDSA 算法进行签名
```
X9.62 ECDSA Signature with SHA-384
```

3. Certificate Signature Value
证书数字签名的结果，该部分不是证书 body 的部分，证书的 body 部分未加密，公开的
用户根据证书的内容知道证书数字签名的算法，利用相同算法和 CA 的公钥对数字签名的值解密
得到摘要信息，再根据证书的内容，用相同的哈希算法对证书内容进行哈希运算
最好比对哈希运算的结果和数字签名解密后的结果（哈希运算不可逆）



## 浏览器中查看网站的证书
用 google chrome 进入如维基百科网页时，点击网页 url 左侧的小锁，查看证书时发现最后有个指纹信息，
![](img/2023-05-29-21-05-34.png)


证书本身没有最后的指纹的，该指纹根据网上的说法，是对整个证书做了一个哈希运算，
将证书导出成 .crt 的文件后用命令来查看证书无最后的指纹部分
```bash
openssl x509 -in _.wikipedia.org.crt -text -noout
```


## 用户验证数字证书的过程
1. 用户根据证书的 body 部分得知数字签名的算法，用相同的算法和 CA 的公钥解密签名数值，得到摘要信息
2. 根据证书 body 部分的哈希算法，用相同的算法对 body 进行哈希运算，得到一个摘要值
3. 比对自己计算得到的摘要和数字签名解密后得到的摘要值，相同则证书可信

## 证书文件名后缀
> [Certificate filename extensions](https://en.wikipedia.org/wiki/X.509#Certificate_filename_extensions)

> .pem – (Privacy-enhanced Electronic Mail) Base64 encoded DER certificate, 
> enclosed between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----
>
> .cer, .crt, .der – usually in binary DER form, but Base64-encoded certificates are common too (see .pem above)
>
> .p7b, .p7c – PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)
>
> .p12 – PKCS#12, may contain certificate(s) (public) and private keys (password protected)
>
> .pfx – PFX, predecessor of PKCS#12 (usually contains data in PKCS#12 format, e.g., with PFX files generated in IIS)


> [Difference between pem, crt, key files](https://stackoverflow.com/questions/63195304/difference-between-pem-crt-key-files)
> [ PKIX Textual Encodings](https://www.rfc-editor.org/rfc/rfc7468)


- 一般证书文件名字后缀为 `.cert` 或 `.crt`

- `.csr` 指 `certificate signing request`，如生成自签名证书时提交的证书申请文件使用的后缀

- `.pem` Privacy Enhanced MailBase64，编码的证书，通常为公钥文件；Base64 编码的 DER 格式的证书文件也可以用 `.pem` 后缀
Base64编码的DER证书是一种将DER编码格式的数字证书转换为Base64编码的文件格式。
DER（Distinguished Encoding Rules）是ASN.1（抽象语法标记一）的一种编码方式，用于将数据结构进行编码，通常用于数字证书中。
Base64编码则是一种用64个字符来表示二进制数据的编码方式，常用于网络传输等场合。

将DER编码格式的数字证书进行Base64编码可以让数字证书在传输过程中不被损坏或者修改，
同时也可以避免某些系统在传输二进制数据时遇到字符集和编码的问题。通过将数字证书转换为Base64编码的格式，
可以将其保存为一段文本并发送到其他系统或者存储在数据库中。

`.pem` 可以用来作为 `openssl` 证书文件的后缀，比较通用


- `.key` 通常为私钥文件

### .crt 和 .pem 文件的区别
`.pem` 和 `.crt` 文件都是存储加密信息的文件格式，它们之间的区别如下：

1. `.pem` 文件是 OpenSSL 中的一种通用格式，可以存储多种加密信息，包括证书、公钥、私钥等，
其文件内容是经过 BASE64 编码的 ASCII 文本。
由于其灵活性，.pem 文件常用于在不同的系统之间共享证书和密钥等信息。


2. `.crt` 文件虽然也可以存储证书信息，但通常仅用于存储公钥证书，其文件内容也是经过 BASE64 编码的 ASCII 文本。
`.crt` 文件中的证书是经过具体的编码标准 DER 或/和 PEM 编码后的，**该文件中没有包含私钥**。
`.crt` 也可以是 X.509 证书的扩展名，用于标识证书类型，通常以.pem 或 .der 格式保存。


总之，.pem 和 .crt 都是常用的存储加密信息的文件格式，它们的主要区别是.pem 除了可以存储公私钥、证书等信息，还包括其他类型



# 多种算法综合运用
- Alice 发送数据给 Bob
## Pb{Sa[hash(data)]+data}
1. Alice 将数据用哈希算法加密得到摘要
2. Alice 将摘要用自己的私钥加密进行数字签名
3. Alice 将数字签名和数据用 Bob 的公钥加密

## key{Sa[hash(data)]+data}+Pb(key)
1. Alice 将数据用哈希算法加密得到摘要
2. Alice 将摘要和数据一起用自己的私钥加密
3. Alice 用一个对称的密钥加密第二部的数据得到密文
4. Alice 用 Bob 的公钥加密第三步的对称密钥


# IKE 互联网密钥交换协议
> [IKE](https://en.wikipedia.org/wiki/Internet_Key_Exchange#IKEv1_phases)

> In computing, Internet Key Exchange (IKE, sometimes IKEv1 or IKEv2, depending on version)
> is the protocol used to set up a security association (SA) in the IPsec protocol suite.


## Diffie–Hellman key exchange 
> [Diffie–Hellman key exchange](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange)


- 通信双方在公共信道中安全交换密钥的一种安全方法

> In the Diffie–Hellman key exchange scheme, each party generates a public/private key pair
> and distributes the public key. 
> After obtaining an authentic copy of each other's public keys, 
> Alice and Bob can compute a shared secret offline. 
> The shared secret can be used, for instance, as the key for a symmetric cipher.


# PKI 公共密钥加密体系
> [Public key infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure)

> A public key infrastructure (PKI) is a set of roles, policies, hardware, 
> software and procedures needed to create, manage, distribute, use, 
> store and revoke digital certificates and manage public-key encryption. 


# 安全协议 SSL/TLS
> [What is an SSL Certificate?](https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https)
> [What is SSL?](https://www.ssl.com/faqs/faq-what-is-ssl/)

- SSL 和 TLS 都是安全协议，保证数据在网络中安全传输
- TLS 是 SSL 的升级，当前主要用 TLS
- TLS 协议在应用层和运输层之间位置

原来的 http 是不安全的明文传输协议，后来的 https 即为 http 和 TLS 的组合，对数据加密，更安全



# Base64 编码
> [Base64](https://en.wikipedia.org/wiki/Base64)
> [What is Base64?](https://base64.guru/learn/what-is-base64)

> In computer programming, Base64 is a group of binary-to-text encoding schemes 
> that represent binary data (more specifically, a sequence of 8-bit bytes) 
> in sequences of 24 bits that can be represented by four 6-bit Base64 digits.

- Base64 是一种编码方式，将 8 bit 字节的二进制数据转换为可打印字符的编码方法
- Base64 不是加密算法，是可以破解的，用来将二进制数据显示为可打印的文本字符
- Base64 常用于邮件中传输二进制文件，以及证书中使用等，有些邮件系统仅支持 ASCII 文本
- CA 证书文件，公私钥文件等使用的是 Base64 编码


# OpenSSL 加密工具
> [OpenSSL](https://www.openssl.org/)

- OpenSSL 是一个开源的用于加密和安全通信的软件包
- OpenSSL 包含三个组件：
  - libcrypto 
  实现加密和解密的库
  - libssl
  实现 ssl 通信协议的安全库 
  - openssl
  命令行工具


# openssl 命令行工具
openssl 是实现加密和解密的命令行工具

## 三种命令
输入 `openssl` 回车相当于 `openssl help`，可看见命令说明，
共有三种命令：
- standard commands
- Message Digest commands 
- Cipher commands

```bash
[root@ubuntu22 ~]$ openssl
help:

Standard commands
asn1parse         ca                ciphers           cmp
cms               crl               crl2pkcs7         dgst
dhparam           dsa               dsaparam          ec
ecparam           enc               engine            errstr
fipsinstall       gendsa            genpkey           genrsa
help              info              kdf               list
mac               nseq              ocsp              passwd
pkcs12            pkcs7             pkcs8             pkey
pkeyparam         pkeyutl           prime             rand
rehash            req               rsa               rsautl
s_client          s_server          s_time            sess_id
smime             speed             spkac             srp
storeutl          ts                verify            version
x509

Message Digest commands (see the `dgst' command for more details)
blake2b512        blake2s256        md4               md5
rmd160            sha1              sha224            sha256
sha3-224          sha3-256          sha3-384          sha3-512
sha384            sha512            sha512-224        sha512-256
shake128          shake256          sm3

Cipher commands (see the `enc' command for more details)
aes-128-cbc       aes-128-ecb       aes-192-cbc       aes-192-ecb
aes-256-cbc       aes-256-ecb       aria-128-cbc      aria-128-cfb
aria-128-cfb1     aria-128-cfb8     aria-128-ctr      aria-128-ecb
aria-128-ofb      aria-192-cbc      aria-192-cfb      aria-192-cfb1
aria-192-cfb8     aria-192-ctr      aria-192-ecb      aria-192-ofb
aria-256-cbc      aria-256-cfb      aria-256-cfb1     aria-256-cfb8
aria-256-ctr      aria-256-ecb      aria-256-ofb      base64
bf                bf-cbc            bf-cfb            bf-ecb
bf-ofb            camellia-128-cbc  camellia-128-ecb  camellia-192-cbc
camellia-192-ecb  camellia-256-cbc  camellia-256-ecb  cast
cast-cbc          cast5-cbc         cast5-cfb         cast5-ecb
cast5-ofb         des               des-cbc           des-cfb
des-ecb           des-ede           des-ede-cbc       des-ede-cfb
des-ede-ofb       des-ede3          des-ede3-cbc      des-ede3-cfb
des-ede3-ofb      des-ofb           des3              desx
rc2               rc2-40-cbc        rc2-64-cbc        rc2-cbc
rc2-cfb           rc2-ecb           rc2-ofb           rc4
rc4-40            seed              seed-cbc          seed-cfb
seed-ecb          seed-ofb          sm4-cbc           sm4-cfb
sm4-ctr           sm4-ecb           sm4-ofb
```

## openssl 语法

openssl 语法格式：
> openssl command [ options ... ] [ parameters ... ]

openssl 查看三种命令和算法：
> openssl list standard-commands | digest-commands | cipher-commands | cipher-algorithms 
> | digest-algorithms | mac-algorithms | public-key-algorithms


> openssl no-XXX [ options ]

## openssl 单项哈希算法加密

### 查看摘要命令和摘要算法
```bash
[root@ubuntu22 ~]$ openssl list -digest-commands
blake2b512        blake2s256        md5               sha1
sha224            sha256            sha3-224          sha3-256
sha3-384          sha3-512          sha384            sha512
sha512-224        sha512-256        shake128          shake256
sm3
```

```bash
[root@ubuntu22 ~]$ openssl list -digest-algorithms | head -n15
Legacy:
  RSA-MD4 => MD4
  RSA-MD5 => MD5
  RSA-RIPEMD160 => RIPEMD160
  RSA-SHA1 => SHA1
  RSA-SHA1-2 => RSA-SHA1
  RSA-SHA224 => SHA224
  RSA-SHA256 => SHA256
  RSA-SHA3-224 => SHA3-224
  RSA-SHA3-256 => SHA3-256
  RSA-SHA3-384 => SHA3-384
  RSA-SHA3-512 => SHA3-512
  RSA-SHA384 => SHA384
  RSA-SHA512 => SHA512
  RSA-SHA512/224 => SHA512-224
```


几种不同写法：

如用 md5 算法对文件加密，可以用 `openssl md5` 或者 `openssl dgst -md5`，
或者用 `md5sum` 工具加密，得到的结果相同

```bash
[root@ubuntu22 ~]$ whatis md5sum
md5sum (1)           - compute and check MD5 message digest
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl md5 /etc/passwd
MD5(/etc/passwd)= 8198e91069df077218a4c0f001d81653
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl dgst -md5 /etc/passwd
MD5(/etc/passwd)= 8198e91069df077218a4c0f001d81653
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ md5sum /etc/passwd
8198e91069df077218a4c0f001d81653  /etc/passwd
```

用 `openssl dgst` 时不指定加密算法，则默认为 `sha256`
```bash
[root@ubuntu22 ~]]$ openssl dgst /etc/passwd
SHA256(/etc/passwd)= dfcb0be8c072dacdb3434106fa61d00911c34d282f7490b1b93d1e70de8d6d79
```

## openssl passwd 生成用户密码
`openssl passwd --help` 查看帮助，列出不同分类的选项
`man openssl passwd` 查看更详细的帮助

不加任何参数加密相同的数结果不同
```bash
[root@ubuntu22 ~]$ openssl passwd 123
$1$B2FtRHhm$1iT1HdlXBF8Ug/UTwAeYi/
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl passwd 123
$1$igbevHLN$mFSXe43py6RacnAU0MFAQ1
```

- 上面加密后的内容由三部分组成，由 `$` 分隔
- 第一部分为加密算法，默认为 `1`，代表 md5，`5` 表示 sha256，`6` 表示 `sha512`
- 第二部分为盐值，同样的数据，算法相同，但 salt 不同，得到的密文不同
- 第三部分为利用前面的加密算法和盐值计算出来的密文
可以指定相同的盐值和算法，这样相同的内容得到的密文也相同：
```bash
[root@ubuntu22 ~]$ openssl passwd -1 -salt "igbevHLN"
Password:
$1$igbevHLN$mFSXe43py6RacnAU0MFAQ1
[root@ubuntu22 ~]$ openssl passwd -1 -salt "igbevHLN" 123
$1$igbevHLN$mFSXe43py6RacnAU0MFAQ1
```

## openssl rand 生成随机数
```bash
[root@ubuntu22 ~]$ openssl rand --help
Usage: rand [options] num

General options:
 -help               Display this summary
 -engine val         Use engine, possibly a hardware device

Output options:
 -out outfile        Output file
 -base64             Base64 encode output
 -hex                Hex encode output

Random state options:
 -rand val           Load the given file(s) into the random number generator
 -writerand outfile  Write random data to the specified file

Provider options:
 -provider-path val  Provider load path (must be before 'provider' argument if required)
 -provider val       Provider to load (can be specified multiple times)
 -propquery val      Property query used when fetching algorithms

Parameters:
 num                 Number of bytes to generate
```

- 不指定编码，则显示的字符可能乱码或不可打印字符等
base64 编码用 6 位来组成一个新的字节
一个字节有 8 位，如果想生成的随机字符最后没有 `=`（位数不足时补充），则指定位数需要同时被 6 和 8 整除,
如指定 num 为 3 字节，则 24 位，每 6 位重新生成一个字符，最后看到 4 个字符
```bash
[root@ubuntu22 ~]$ openssl rand 3
kC⚌[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl rand -base64 3
QptA
[root@ubuntu22 ~]$ openssl rand -hex 3
f9956f
```




- 其他随机数生成器，有 `/dev/random` 或 `/dev/urandom` 

### 创建新用户并生成指定长度的随机密码
如果想生成 8 字符的随机密码，8 字符需要 48 位，对应 6 字节，如下：
```bash
[root@lvs-2 ~]$ openssl rand -base64 6
VYO4OHIt
```

如果想生成 6 字符的随机密码，需要 36 位，只能指定 4 字节，然后提取前 6 字符，如下：
```bash
[root@lvs-2 ~]$ openssl rand -base64 4 | cut -c1-6
jsCFKA

```


## openssl 生成密钥对
- 先生成私钥，然后从私钥中提取公钥

### openssl genrsa 生成私钥
- `man openssl genrsa` 查看详细说明
- ` openssl genrsa --help` 查看命令选项

```bash
[root@ubuntu22-c0 ~]$ openssl genrsa --help
Usage: genrsa [options] numbits

General options:
 -help               Display this summary
 -engine val         Use engine, possibly a hardware device

Input options:
 -3                  (deprecated) Use 3 for the E value
 -F4                 Use the Fermat number F4 (0x10001) for the E value
 -f4                 Use the Fermat number F4 (0x10001) for the E value

Output options:
 -out outfile        Output the key to specified file
 -passout val        Output file pass phrase source
 -primes +int        Specify number of primes
 -verbose            Verbose output
 -traditional        Use traditional format for private keys
 -*                  Encrypt the output with any supported cipher

Random state options:
 -rand val           Load the given file(s) into the random number generator
 -writerand outfile  Write random data to the specified file

Provider options:
 -provider-path val  Provider load path (must be before 'provider' argument if required)
 -provider val       Provider to load (can be specified multiple times)
 -propquery val      Property query used when fetching algorithms

Parameters:
 numbits             Size of key in bits
```


- 生成私钥输出到文件，无加密
```bash
[root@ubuntu22-c0 ~]$ openssl genrsa -out test.key
[root@ubuntu22-c0 ~]$ ll test.key
-rw------- 1 root root 1704 Jun  3 11:44 test.key
[root@ubuntu22-c0 ~]$
[root@ubuntu22-c0 ~]$ head -n2 test.key
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCywavH87VWTweU
[root@ubuntu22-c0 ~]$
[root@ubuntu22-c0 ~]$ tail -n2 test.key
eT/UeRhqIprQyqIW0l3x0yY=
-----END PRIVATE KEY-----
```


- 生成私钥输出到文件，加密
查看帮助文档说明，生成私钥时可以指定一种加密算法对文件加密：
`man openssl genrsa` 查看帮助，加密算法结合 `-passout` 选项使用
```bash
OPTIONS
  -help
      Print out a usage message.

  -out filename
      Output the key to the specified file. If this argument is not specified then standard output is used.

  -passout arg
      The output file password source. For more information about the format see
      openssl-passphrase-options(1).

  -aes128, -aes192, -aes256, -aria128, -aria192, -aria256, -camellia128, -camellia192, -camellia256, -des,
  -des3, -idea
      These options encrypt the private key with specified cipher before outputting it. If none of these
      options is specified no encryption is used. If encryption is used a pass phrase is prompted for if it
      is not supplied via the -passout argument.
```

密码输入的方式通过 `man openssl-passphrase-options` 查看帮助
```bash
OPTIONS
   Pass Phrase Option Arguments
       Pass phrase arguments can be formatted as follows.

       pass:password
           The actual password is password. Since the password is visible to utilities (like 'ps' under Unix) this form should
           only be used where security is not important.

       env:var
           Obtain the password from the environment variable var. Since the environment of other processes is visible on
           certain platforms (e.g. ps under certain Unix OSes) this option should be used with caution.

       file:pathname
           The first line of pathname is the password. If the same pathname argument is supplied to -passin and -passout
           arguments then the first line will be used for the input password and the next line for the output password.
           pathname need not refer to a regular file: it could for example refer to a device or named pipe.

       fd:number
           Read the password from the file descriptor number. This can be used to send the data via a pipe for example.

       stdin
           Read the password from standard input.
```


加密私钥文件，指定算法为 `-des3`，直接写明密码或者通过标准输入读入密码
```bash
[root@ubuntu22-c0 ~]$ openssl genrsa -out test2.key -des3 -passout pass:"123"
[root@ubuntu22-c0 ~]$
[root@ubuntu22-c0 ~]$ openssl genrsa -out test2.key -des3 -passout stdin
123
[root@ubuntu22-c0 ~]$
[root@ubuntu22-c0 ~]$ ll test*
-rw------- 1 root root 1854 Jun  3 14:29 test2.key
-rw------- 1 root root 1704 Jun  3 11:44 test.key
-rw-r--r-- 1 root root  451 Jun  3 11:51 test.pubkey
```

解密加密的私钥
```bash
[root@ubuntu22-c0 ~]$ openssl rsa -in test2.key -out test2.key2
Enter pass phrase for test2.key:
writing RSA key
[root@ubuntu22-c0 ~]$ ls
shell_scripts  snap  test2.key  test2.key2  test.key  test.pubkey
```


### openssl rsa 从私钥中提取公钥
- `man openssl rsa` 查看帮助
- `openssl rsa -help` 查看命令选项
```bash
[root@ubuntu22-c0 ~]$ openssl rsa -help
Usage: rsa [options]

General options:
 -help               Display this summary
 -check              Verify key consistency
 -*                  Any supported cipher
 -engine val         Use engine, possibly a hardware device

Input options:
 -in val             Input file
 -inform format      Input format (DER/PEM/P12/ENGINE
 -pubin              Expect a public key in input file
 -RSAPublicKey_in    Input is an RSAPublicKey
 -passin val         Input file pass phrase source

Output options:
 -out outfile        Output file
 -outform format     Output format, one of DER PEM PVK
 -pubout             Output a public key
 -RSAPublicKey_out   Output is an RSAPublicKey
 -passout val        Output file pass phrase source
 -noout              Don't print key out
 -text               Print the key in text
 -modulus            Print the RSA key modulus
 -traditional        Use traditional format for private keys

PVK options:
 -pvk-strong         Enable 'Strong' PVK encoding level (default)
 -pvk-weak           Enable 'Weak' PVK encoding level
 -pvk-none           Don't enforce PVK encoding

Provider options:
 -provider-path val  Provider load path (must be before 'provider' argument if required)
 -provider val       Provider to load (can be specified multiple times)
 -propquery val      Property query used when fetching algorithms
```

从指定的私钥中提取公钥：
```bash
[root@ubuntu22-c0 ~]$ openssl rsa -in test.key -pubout -out test.pubkey
writing RSA key
[root@ubuntu22-c0 ~]$ ll test.*
-rw------- 1 root root 1704 Jun  3 11:44 test.key
-rw-r--r-- 1 root root  451 Jun  3 11:51 test.pubkey
[root@ubuntu22-c0 ~]$
[root@ubuntu22-c0 ~]$ head -n2 test.pubkey
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAssGrx/O1Vk8HlNqJnwu7
[root@ubuntu22-c0 ~]$
[root@ubuntu22-c0 ~]$ tail -n2 test.pubkey
sQIDAQAB
-----END PUBLIC KEY-----
```


从加密的私钥中提取公钥：
```bash
[root@ubuntu22-c0 ~]$ openssl rsa -in test2.key -pubout -out test2.pubkey
Enter pass phrase for test2.key:
writing RSA key
[root@ubuntu22-c0 ~]$ ll test*
-rw------- 1 root root 1854 Jun  3 14:29 test2.key
-rw------- 1 root root 1704 Jun  3 14:38 test2.key2
-rw-r--r-- 1 root root  451 Jun  3 14:38 test2.pubkey
-rw------- 1 root root 1704 Jun  3 11:44 test.key
-rw-r--r-- 1 root root  451 Jun  3 11:51 test.pubkey
```


# mkpasswd 密码生成工具
ubuntu22.04 上输入 `mkpasswd` 会提示安装 `whois`，安装后查看 `mkpasswd`
```bash
[root@docker ~]$ whatis mkpasswd
mkpasswd (1)         - Overfeatured front end to crypt(3)
```
```bash
[root@docker ~]$ mkpasswd -h
Usage: mkpasswd [OPTIONS]... [PASSWORD [SALT]]
Crypts the PASSWORD using crypt(3).

      -m, --method=TYPE     select method TYPE
      -5                    like --method=md5crypt
      -S, --salt=SALT       use the specified SALT
      -R, --rounds=NUMBER   use the specified NUMBER of rounds
      -P, --password-fd=NUM read the password from file descriptor NUM
                            instead of /dev/tty
      -s, --stdin           like --password-fd=0
      -h, --help            display this help and exit
      -V, --version         output version information and exit

If PASSWORD is missing then it is asked interactively.
If no SALT is specified, a random one is generated.
If TYPE is 'help', available methods are printed.
```

例如，想要对串字符加密，指定盐，指定长度
`-5` 指定加密算法为 md5crypt，指定盐为 `kubernet`，加密字符串为 `lixiaowan`
```bash
[root@docker ~]$ mkpasswd -5 -S kubernet lixiaowan
$1$kubernet$KDGmSBJdPB6c5D4N0K4C6/
```
真正加密的密码为 `KDGmSBJdPB6c5D4N0K4C6`，前面为盐，`$1` 为加密算法，因此用 cut 分隔取密码的前 15 位
```bash
[root@docker ~]$ mkpasswd -5 -S kubernet lixiaowan| cut -d$ -f4 | cut -c1-15
KDGmSBJdPB6c5D4
```
如果想设置包含特殊字符的密码，则设置一个 16 位包含特殊字符，大小写和数字的密码：`_KDGmSBJdPB6c5D4`


# OpenCA 建立私有 CA 颁发自签名证书
> [OpenCA PKI](https://www.openca.org/projects/openca/)

- OpenCA 是一个开源的通过网络实现 CA（Certificate Authority，数字认证机构）功能的软件
- OpenCA 可以颁发和管理证书
- OPEN SOURCE PKI MANAGEMENT SOFTWARE


## 创建私有 CA
- 要有 OpenCA 软件包
- 有 openssl 命令行工具和 openssl-libs


### openssl 配置文件
- 查看 openssl 说明
```bash
[15:11:33 root@ubuntu2004 ~]#dpkg -s openssl
Package: openssl
Status: install ok installed
Priority: optional
Section: utils
Installed-Size: 1257
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Architecture: amd64
Multi-Arch: foreign
Version: 1.1.1f-1ubuntu2.19
Depends: libc6 (>= 2.15), libssl1.1 (>= 1.1.1)
Suggests: ca-certificates
Conffiles:
 /etc/ssl/openssl.cnf fb92a2dab53f11f4f5f22adc5257b553
Description: Secure Sockets Layer toolkit - cryptographic utility
 This package is part of the OpenSSL project's implementation of the SSL
 and TLS cryptographic protocols for secure communication over the
 Internet.
 .
 It contains the general-purpose command line binary /usr/bin/openssl,
 useful for cryptographic operations such as:
  * creating RSA, DH, and DSA key parameters;
  * creating X.509 certificates, CSRs, and CRLs;
  * calculating message digests;
  * encrypting and decrypting with ciphers;
  * testing SSL/TLS clients and servers;
  * handling S/MIME signed or encrypted mail.
Homepage: https://www.openssl.org/
Original-Maintainer: Debian OpenSSL Team <pkg-openssl-devel@lists.alioth.debian.org>
```


- 查看 openssl 配置文件
```bash
[root@ubuntu22-c0 shell_scripts]$ dpkg -L openssl | grep -Ei "^\/etc\/"
/etc/ssl
/etc/ssl/certs
/etc/ssl/openssl.cnf
/etc/ssl/private
```

- 证书配置文件为 `/etc/ssl/openssl.cnf`，里面指定了证路径的一些设置：
```bash
76  ####################################################################
  1 [ ca ]
  2 default_ca  = CA_default        # The default ca section
  3
  4 ####################################################################
  5 [ CA_default ]
  6
  7 dir     = ./demoCA      # Where everything is kept
  8 certs       = $dir/certs        # Where the issued certs are kept
  9 crl_dir     = $dir/crl      # Where the issued crl are kept
 10 database    = $dir/index.txt    # database index file.
 11 #unique_subject = no            # Set to 'no' to allow creation of
 12                     # several certs with same subject.
 13 new_certs_dir   = $dir/newcerts     # default place for new certs.
 14
 15 certificate = $dir/cacert.pem   # The CA certificate
 16 serial      = $dir/serial       # The current serial number
 17 crlnumber   = $dir/crlnumber    # the current crl number
 18                     # must be commented out to leave a V1 CRL
 19 crl     = $dir/crl.pem      # The current CRL
 20 private_key = $dir/private/cakey.pem# The private key
 21
 22 x509_extensions = usr_cert      # The extensions to add to the cert
```

- `dir` 指明证书文件的目录，如果 `certs`，`newcerts` 等子目录就在当前目录下，
则将 `dir` 目录改为当前目录 `.`

- CA 给申请证书的机构颁发证书签名时如果指定颁发证书的配置文件为该文件，则文件的路径要和
配置文件中指定的路径一致，否则会出错；如果不指定配置文件，则默认用该配置文件

- `database` 和 `serial` 两个文件的作用
`database` 部分用于指定证书签名过程中使用的索引文件，即用于存储证书及其签发/撤销信息的数据库。

在 OpenSSL 中，签名证书需要一个可靠的证书颁发机构（CA）进行签名，以确认证书是可信的。
此时，签名证书的使用者向 CA 机构发送证书请求，在证书请求中包括需要签名证书的信息，例如证书的名称、主题、有效期等。

`database` 部分的索引文件主要用于存储这些证书请求信息，
索引文件通常包括两个文件：一个是索引文件（`.index`），存储证书请求的信息和状态（签名、撤销等），
另一个是序列号文件（`.serial`），存储证书请求的序列号。

当 CA 机构收到证书请求后，`openssl ca` 命令会使用数据库索引文件中的证书请求信息进行验证，
并将证书的签名信息添加到索引文件中，以便在以后的验证过程中能够识别证书是否曾经被撤销或有效期到期。

总之，`database` 部分的索引文件是 OpenSSL 中用于存储证书签名相关信息的数据库，
用于维护证书签名和撤销的状态。它是 OpenVPN 证书颁发和管理过程中不可缺少的一部分。

这两个文件默认没有，要在对应的目录中创建，否则给证书签名时会报错，只用创建文件不用写内容


- crl文件是Certificate Revocation List（证书吊销列表）的缩写，是一种包含吊销数字证书序列号的文件。
crl文件通常由数字证书认证机构（CA）生成和维护，用于发布吊销数字证书的信息，从而确保数字证书的有效性和准确性。


- 证书文件在 `/etc/ssl` 目录中
```bash
[root@zabbix ssl]$ pwd
/etc/ssl
[root@zabbix ssl]$ ls
certs  openssl.cnf  private
```

- 已经签发的证书在 `certs` 子目录中
里面有系统内置的一些根证书等，和 windows 系统中内置的根证书类似
```bash
[root@zabbix ssl]$ ls certs/ | tail -n5
USERTrust_ECC_Certification_Authority.pem
USERTrust_RSA_Certification_Authority.pem
vTrus_ECC_Root_CA.pem
vTrus_Root_CA.pem
XRamp_Global_CA_Root.pem
```

- `private` 子目录存放私钥

- 新颁发的证书默认放在  `newcerts` 子目录中
初始没有该目录，可以创建后将新颁发的证书放该目录下

- 证书配置文件还指明了颁发证书的政策：
```bash
  1 # For the CA policy
  2 [ policy_match ]
  3 countryName        = match
  4 stateOrProvinceName    = match
  5 organizationName   = match
  6 organizationalUnitName  = optional
  7 commonName      = supplied
  8 emailAddress        = optional
```

`optional` 指颁发证书时申请机构的该项可以和 CA 不一致
`match` 指颁发证书时申请机构的该项必须和 CA 一致
`supplied` 必须填写该项信息

默认的有三个参数都必须精准匹配，如果后面 CA 证书和申请证书时提交的参数不一致，
则 CA 给 .csr 签名时会失败，可以将 `match` 改为 `optional`


- 配置文件指定证书默认大小
```bash
144 ####################################################################
  1 [ req ]
  2 default_bits        = 2048
  3 default_keyfile     = privkey.pem
  4 distinguished_name  = req_distinguished_name
  5 attributes      = req_attributes
  6 x509_extensions = v3_ca # The extensions to add to the self signed cert
  7
```

- 配置文件还指定了证书的有效期等
```bash
112
  1 default_days    = 365           # how long to certify for
  2 default_crl_days= 30            # how long before next CRL
  3 default_md  = default       # use public key default MD
  4 preserve    = no            # keep passed DN ordering
```
1. 默认证书有效期为 365 天
2. `default_crl_days` 默认为 30 天，指定生成 CRL（证书吊销列表）的默认时间间隔
证书即使在有效期内，如果被吊销，即在吊销列表中，则为不可信的证书
该有效期过了后，会重新生成新的 CRL，但原来被吊销的证书仍是吊销状态


#### 证书有效期和证书吊销列表的有效期
证书有效期可以确保数字证书在有效期内是可信的，并防止已过期的数字证书被误用。

但是，即使数字证书仍在有效期内，如果数字证书的私钥或相关证书信息已经遭到泄露，
或者数字证书本身被假冒或篡改，数字证书也不再是可信的。这时就需要使用证书吊销列表（CRL）来撤销数字证书。

CRL是一个由数字证书签发机构（CA）发布的列表，包含已经被撤销的数字证书的序列号，用于指示哪些数字证书不再可信。
在使用数字证书时，可以使用CRL文件来检查数字证书是否被撤销。
如果数字证书的序列号存在于CRL文件中，那么该数字证书就被认为是不可信的。

因此，与数字证书有效期不同，CRL提供了一种有效的机制，用于撤销数字证书，即使数字证书仍在有效期内。
CRL的存在可以提高数字证书的安全性，并帮助保护数字证书持有人免受欺诈行为的影响。

CRL本身也有其有效期。
default_crl_days 是OpenSSL设置用于生成证书吊销列表（CRL）的默认时间间隔。
它指定了，从上一次生成CRL的日期开始，需要多少天后再次生成CRL。
因此，default_crl_days 不会影响数字证书本身的有效期，而是影响与数字证书相关的CRL更新时间。



### openssl req 交互式创建 CA 自签名证书
`man openssl req` 或 `openssl req --help` 查看帮助
```bash
openssl-req - PKCS#10 certificate request and certificate generating command
```

- 为新证书创建文件夹
```bash
[root@zabbix ssl]$ mkdir newcerts
[root@zabbix ssl]$ ls
certs  newcerts  openssl.cnf  private
```

- 创建 CA 自签名证书
```bash
[root@zabbix ssl]$ openssl req -x509 -newkey rsa:2048 -keyout private/ca.key -noenc -days 365 -out newcerts/cacrt.pem
....+.....+.......+...+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+...+...+....+...+..............+.+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.................+....+............+...+......+.....+............+.......+..+.+...............+..+...+...+....+...........+.+...+...........+......+......+....+........+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*...+......+.+..+.+.....+.+...+...+.....+...+..........+..+...+......+.+..+.+...........+......+....+...+...+.......................+......+......+....+.....+......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.....+...............+..+...+......+......+.+..+.............+..............+.+............+..+...+.+..+.........+.........+.+.........+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:beijing
Locality Name (eg, city) []:beijing
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:ubuntu22.04
Email Address []:
[root@zabbix ssl]$ ls
ca.key  certs  newcerts  openssl.cnf  private
[root@zabbix ssl]$ ls newcerts/
cacrt.pem
[root@zabbix ssl]$
```

1. `req` 子命令表示 `request`，用于生成证书

2. `x509` 指定证书格式为 x.509 证书格式（[4.Certificate and Certificate Extensions Profile]()https://datatracker.ietf.org/doc/html/rfc5280#section-4） 

3. `-newkey` 表示生成新的私钥文件，如果已经为 CA 生成私钥文件，则可以用 `-key` 指定私钥文件
没有私钥可以新生成私钥，后面接一个参数，指定生成私钥的算法，如 `rsa`，然后指定私钥文件的大小，如 `rsa:2048`，单位为 bit
```bash
-newkey arg
           This option is used to generate a new private key unless -key is given.  It is subsequently used as if it was given
           using the -key option.

           This option implies the -new flag to create a new certificate request or a new certificate in case -x509 is given.

           The argument takes one of several forms.

           [rsa:]nbits generates an RSA key nbits in size.  If nbits is omitted, i.e., -newkey rsa is specified, the default
           key size specified in the configuration file with the default_bits option is used if present, else 2048.

           All other algorithms support the -newkey algname:file form, where file is an algorithm parameter file, created with
           "openssl genpkey -genparam" or an X.509 certificate for a key with appropriate algorithm.

           param:file generates a key using the parameter file or certificate file, the algorithm is determined by the
           parameters.

           algname[:file] generates a key using the given algorithm algname.  If a parameter file file is given then the
           parameters specified there are used, where the algorithm parameters must match algname.  If algorithm parameters
           are not given, any necessary parameters should be specified via the -pkeyopt option.

           dsa:filename generates a DSA key using the parameters in the file filename. ec:filename generates EC key (usable
           both with ECDSA or ECDH algorithms), gost2001:filename generates GOST R 34.10-2001 key (requires gost engine
           configured in the configuration file). If just gost2001 is specified a parameter set should be specified by
           -pkeyopt paramset:X
```

4. `-keyout filename` 指定用 `-newkey` 生成的私钥存放在什么文件中，即文件名
这里按照规范放在 `private` 文件夹中

5. `-noenc` 表示不加密私钥文件，即 `no encryption`

6. `-days` 指定证书的有效期

7. `-out` 指定证书输出文件

8. 交互式输入参数
生成证书的过程中会需要狡猾输入一些国家，地方等内容，
这里需要注意如果证书配置文件中的 `policy_match` 对国家，省等参数做了严格的限制（match），
则以后该 CA 颁发证书是，证书申请者必须匹配国家和省

- 国家代码见：[Country Code](https://country-code.cl/)


### openssl req 非交互式创建 CA 自签名证书
在交互式选项中，提前指定需要交互式输入的参数，通过 `-subj` 选项指定，后面根参数
参数通过 `/type0=value0/type1=value1/type2=...` 形式指定，即键值的形式，键以 `/` 开头
支持的键及其含义如下：
```bash
C         <iso-country-code>    Country Name
ST        <state>               State or Province Name
L         <locality>            Locality Name
O         <organization>        Organization Name
OU        <organizational-unit> Organizational Unit Name
CN        <common-name>         Common Name
emailAddress           = test@email.address
```

非交互式方式创建证书：
指定参数不用写全，这里只指定国家和省
```bash
[root@zabbix ssl]$ openssl req -x509 -newkey rsa:2048 -keyout private/ca1.key -noenc \
> -days 365 -subj "/C=CN/ST=beijing" -out newcerts/cacrt1.pem
...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*........+.......+...+..+..........+...........+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*...........+.+.........+.....+....+....................+.......+...+......+.....+.+...+..+.+..+.......+......+........+.+......+..+............+....+.....+....+..+...+.+......+.......................+.+..+...+.+.....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
...+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+....+...+........+....+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.........+.+...+..+.........+.+............+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-----
[root@zabbix ssl]$ ls newcerts/
cacrt1.pem  cacrt.pem
[root@zabbix ssl]$ ls private/
ca1.key  ca.key  ssl-cert-snakeoil.key
```


## 生成证书申请文件
为需要申请证书的机构生成证书申请文件
命令和 CA 申请自签名证书一样，注意证书中国家和省等政策要求
证书申请文件的文件后缀为 `.csr`，对于 `openssl`，文件名的后缀很重要


```bash
[root@zabbix ssl]$ openssl req -newkey rsa:2048 -noenc -keyout private/server1.key \
> -subj "/C=CN/ST=beijing/O=test.org/CN=webserver" -out server1.csr
```

生成的 `.csr` 文件不能用 `openssl x509` 命令查看
```bash
[root@zabbix ssl]$ openssl x509 -in server1.csr -noout -text
Could not read certificate from server1.csr
Unable to load certificate
```

### 查看 .csr 文件内容
```bash
[root@zabbix ssl]$ openssl req -in server1.csr -noout -text
```


## CA 对证书签名
用 `openssl ca` 对证书签名

`man openssl ca` 或 `openssl ca --help` 查看帮助
```bash
openssl-ca - sample minimal CA application
```

```bash
[root@zabbix ssl]$ openssl ca -in server1.csr -out server1.crt \
> -cert newcerts/cacrt.pem -keyfile private/ca.key -config openssl.cnf -rand_serial

Using configuration from openssl.cnf
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number:
            6c:35:04:44:c5:aa:85:f6:69:b0:28:a1:62:cd:ea:60:d9:6a:33:ff
        Validity
            Not Before: Jun  3 11:09:03 2023 GMT
            Not After : Jun  2 11:09:03 2024 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = beijing
            organizationName          = test.org
            commonName                = webserver
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            X509v3 Subject Key Identifier:
                8C:61:90:6F:5C:74:AB:F0:EB:4D:BC:8F:FB:A0:C3:18:87:56:A1:69
            X509v3 Authority Key Identifier:
                C6:C4:53:CB:C6:A6:BF:48:9F:69:11:0B:6A:89:A4:DB:5D:EF:85:EB
Certificate is to be certified until Jun  2 11:09:03 2024 GMT (365 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
```

`-config` 指定证书配置文件
`-rand_serial` 生成随机数作为序列号

如果原来没有 `index.txt` 文件，则签名时会报错，提示没有该文件，但创建该文件后，
又会将原来的 `index.txt` 改为 `index.txt.old`，然后将数据写到 `index.txt` 中？
```bash
[root@zabbix ssl]$ ls
certs  index.txt  index.txt.attr  index.txt.old  newcerts  openssl.cnf  private  serial  serial.old  server1.crt  server1.csr
[root@zabbix ssl]$ cat index.txt
V       240602110903Z           6C350444C5AA85F669B028A162CDEA60D96A33FF        unknown /C=CN/ST=beijing/O=test.org/CN=webserver
```

## openssl x509 查看证书文件内容
前面介绍 x509 证书格式由三部分组成，数据部分（待签名部分，证书签名算法，证书签名结果）
在网页浏览器中可以查看证书，也可以通过命令查看

`man openssl x509` 或 `openssl x509 --help` 查看帮助

```bash
[root@zabbix ssl]$ openssl x509 -in newcerts/cacrt.pem -noout -text
```

- `x509` 表示证书的格式为 x.509
- `-in` 后面接证书文件
- `-noout` 阻止输出，不加该选项，则会输出 base64 编码格式文本
- `-text` 以文本形式输入


证书三部分内容标题如下，省略具体内容：
```bash
Certificate:
  Data:
  Signature Algorithm: sha256WithRSAEncryption
  Signature Value:
```


# ssh handshake
> [SSH Handshake Explained](https://goteleport.com/blog/ssh-handshake-explained/)
> [SSH Handshake](https://yabhinav.github.io/security/openssh-handshake-overview/)
> [RFC 6239](https://www.rfc-editor.org/rfc/rfc6239.html#section-3)
> [RFC 5656 SSH ECC Algorithm Integration](https://www.rfc-editor.org/rfc/rfc5656#section-3)
> [Understanding the SSH Encryption and Connection Process](https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process)



```bash
SSH_MSG_KEXINIT           C->S  Contains lists of algorithms
                                acceptable to the client.

SSH_MSG_KEXINIT           S->C  Contains lists of algorithms
                                acceptable to the server.

SSH_MSG_KEXECDH_INIT      C->S  Contains the client's ephemeral
                                elliptic curve Diffie-Hellman key.

SSH_MSG_KEXECDH_REPLY     S->C  Contains a certificate with the
                                server's ECDSA public signature
                                key, the server's ephemeral ECDH
                                contribution, and an ECDSA digital
                                signature of the newly formed
                                exchange hash value.

SSH_MSG_USERAUTH_REQUEST  C->S  Contains the user's name, the
                                name of the service the user is
                                requesting, the name of the
                                authentication method the client
                                wishes to use, and method-specific
                                fields.
```



## SSH protocol version exchange
客户端和服务端双方交换 SSH 版本信息
不同的版本有些功能有差异，因此需要确认双方版本

## Key Exchange Initialization 双方协商算法
- 双方发送 `SSH_MSG_KEXINIT` 消息协商使用的加密算法
  该消息中携带自己支持的加密算法列表，以及算法的优先级
  为了后面使用算法加密能达成一致，使用双方都支持的算法

```bash
SSH_MSG_KEXINIT   C->S  Contains lists of algorithms
                        acceptable to the client.

SSH_MSG_KEXINIT   S->C  Contains lists of algorithms
                        acceptable to the server.
```

`SSH_MSG_KEXINIT` 的内容如下：
```bash
byte         SSH_MSG_KEXINIT
byte[16]     cookie (random bytes)
name-list    kex_algorithms
name-list    server_host_key_algorithms
name-list    encryption_algorithms_client_to_server
name-list    encryption_algorithms_server_to_client
name-list    mac_algorithms_client_to_server
name-list    mac_algorithms_server_to_client
name-list    compression_algorithms_client_to_server
name-list    compression_algorithms_server_to_client
name-list    languages_client_to_server
name-list    languages_server_to_client
boolean      first_kex_packet_follows
uint32       0 (reserved for future extension)
```


## Key Exchange and Server Authentication
> [4.Key Exchange and Server Authentication](https://www.rfc-editor.org/rfc/rfc6239.html#section-4)
> [RFC 5656 SSH ECC Algorithm Integration](https://www.rfc-editor.org/rfc/rfc5656#section-3)


### 客户端发送 SSH_MSG_KEX_ECDH_INIT 消息

- 客户端生成一对临时的公私钥对，该密钥对仅在 key exchange 阶段临时有效，不会存在文件中保存下来，因此更安全
如后面服务端认证客户端时，即 `SSH_MSG_USERAUTH_REQUEST` 阶段客户端发送的公钥和此处的不同

- 客户端将其临时公钥发送给服务端，如发送 `SSH_MSG_KEX_ECDH_INIT` message
```bash
byte     SSH_MSG_KEX_ECDH_INIT
string   Q_C, client's ephemeral public key octet string
```


### 服务端回应客户端 SSH_MSG_KEX_ECDH_REPLY 消息

- 服务端监听 `SSH_MSG_KEX_ECDH_INIT` message，一旦接受到该消息，
  发送 `SSH_MSG_KEX_ECDH_REPLY` 响应客户端，内容由三部分组成：
```bash
byte     SSH_MSG_KEX_ECDH_REPLY
string   K_S, server's public host key
string   Q_S, server's ephemeral public key octet string
string   Sig_S, the signature on the exchange hash
```

1) `K_S` 为服务端的 host key，非临时的，服务端有针对不同的算法生成的多个公私钥对，
根据前面协商的算法，发送给客户端其公钥文件
如服务端为 ubuntu20.04，其 `/etc/ssh` 目录中有几种不同算法的公钥，
其中 `.pub` 为公钥文件，文件名可以看出所用的算法
```bash
[18:59:15 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```

2) `Q_S` 为服务端生成的临时的公私钥对中的公钥

3) 服务端对 exchange hash H 的签名
签名用 host private key
exchange hash H 计算的内容为：
```bash
string   V_C, client's identification string (CR and LF excluded)
string   V_S, server's identification string (CR and LF excluded)
string   I_C, payload of the client's SSH_MSG_KEXINIT
string   I_S, payload of the server's SSH_MSG_KEXINIT
string   K_S, server's public host key
string   Q_C, client's ephemeral public key octet string
string   Q_S, server's ephemeral public key octet string
mpint    K,   shared secret
```

其中 shared secret value `K` 是服务端利用客户端的公钥和自己的生成的临时的私钥生成的
（该过程通过 Diffie-Hellman 算法得到）, 共享密钥所用的算法为前面协商的算法，


### 客户端验证服务端的 host public key
1) 客户端收到服务端的消息后，查看服务端的 host public key 是否在自己的 `known_hosts` 文件列表中
2) 客户端利用 host public key，即消息中的 `K_S` 解出 `Sig_S` 签名值，得到 exchange hash `H`
3) 客户端自己计算哈希值，计算的内容和服务端相同，客户端也能计算出一个 shared secret value `K`，
其他的内容的之前交换的信息和服务端的公钥等，将自己计算的结果和解出签名得到的哈希值比对

这一步，如果服务端的 host public key 不在 `known_hosts` 中，则会出现提示信息，
例如服务端为 ubuntu20.04，其 public host key 由下这些：
```bash
[18:59:15 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```


如 `rocky8.6` 作为客户端来连一个服务端时的提示：
```bash
[root@rocky8-3 .ssh]$ ssh 192.168.137.17
The authenticity of host '192.168.137.17 (192.168.137.17)' can't be established.
ECDSA key fingerprint is SHA256:iBJIDP0FkveLmB549s75m3T7qfYU4nuNUKLeJqwRj2M.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
从提示可以看出服务端使用的 host public key 文件为 `ssh_host_ecdsa_key.pub`，
对该公钥进行数字签名的单项哈希算法为 `SHA256`


而客户端 ubuntu22.04 来连接服务器时，提示为：
```bash
[root@ubunut22:~]$ ssh  192.168.137.17
The authenticity of host '192.168.137.17 (192.168.137.17)' can't be established.
ED25519 key fingerprint is SHA256:gLez30G4gynTfEWJe7kvn3I0w5x8a18+/wvDQorzCEk.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
从提示可以看出服务端使用的 host public key为 `ssh_host_ed25519_key.pub`，
对该公钥进行数字前面的单项哈希算法为 `SHA256`, 因此两者的指纹不同


两个不同客户端所看到的指纹不同是因为服务端和客户端在签名协商算法是所确定的算法不同


#### 客户端验证指纹是否正确的方法
此时客户端需要确认指纹是否正确从而确认服务端不是中间人
客户端要比对指纹信息，则需要有信任的渠道知道真正的指纹信息，
用户可以到服务端获取指纹信息，或者联系服务端的管理员获取指纹信息，然后进行比对


服务端查看自己指纹的方式：

1）服务端可以通过连自己查看指纹，但在本例默认的公钥文件为 `ssh_host_ecdsa_key.pub`
```bash
[15:16:39 root@ubuntu2004 /etc/ssh]#ssh 127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:iBJIDP0FkveLmB549s75m3T7qfYU4nuNUKLeJqwRj2M.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

```bash
[19:34:49 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```

2）通过 ssh-keygen 生成指纹进行比对，可以指定对某个公钥文件生成指纹
`ssh-keygen` 是用来管理 ssh 协议用于认证的公钥文件的，
这里的公钥文件如 `ssh_host_ecdsa_key.pub` 和前面 `openssl genrsa` 生成的公私钥格式不同，
是 OpenSSH Fromat
```bash
ssh-keygen generates, manages and converts authentication keys for ssh(1).  
ssh-keygen can create keys for use by SSH protocol version 2.
```

```bash
[15:34:08 root@ubuntu2004 /etc/ssh]#cat ssh_host_ecdsa_key.pub
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGONFbM8g/uU8//Xwk4gCFdyu8ym7g5dc3sNHVzLttlHxx7mA80C9jP3jkKl+F5p/DHZC3OZzk4wDR1bii13RjU= root@cdqz-KPL-W0X
```
- 第一个字段 `ecdsa-sha2-nistp256` 表示用到的签名算法
- 第二字段为 base64 编码的公钥数据


利用 `ssh-keygen` 查看 host public key 的指纹：
```bash
`ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]`
`-l` 表示显示公钥文件的指纹
`-E` 显示用于数字签名的单向哈希算法，可选的有 `sha256` 和 `md5`，默认为 `sha256`
`-f` 指定公钥文件
```

```bash
[15:35:47 root@ubuntu2004 /etc/ssh]#ssh-keygen -l -E "sha256" -f ssh_host_ecdsa_key.pub
256 SHA256:iBJIDP0FkveLmB549s75m3T7qfYU4nuNUKLeJqwRj2M root@cdqz-KPL-W0X (ECDSA)
```

不能直接用 `sha256sum` 来得到指纹，因为 `sha256sum` 会对整个文件做哈希运算，而真正的公钥数据只是该文件的一部分
```bash
[15:36:28 root@ubuntu2004 /etc/ssh]#sha256sum ssh_host_ecdsa_key.pub
d91e18a94935dbbab22b84c5e0eac17db5f99e93927a39de217293d2ed61a2b4  ssh_host_ecdsa_key.pub
```


#### 客户端比对指纹后将服务端的数据加入 known_hosts 文件
- 客户端确认指纹后输入 `yes` 则将服务端的公钥文件，
  如服务端自己连自己，使用的公钥文件为 `ssh_host_ecdsa_key.pub` 
```bash
[15:53:52 root@ubuntu2004 /etc/ssh]#ssh 127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:iBJIDP0FkveLmB549s75m3T7qfYU4nuNUKLeJqwRj2M.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '127.0.0.1' (ECDSA) to the list of known hosts.
root@127.0.0.1's password:
```

输入 `yes` 后，查看 `~/.ssh/known_hosts` 文件，看到该文件中存有公钥文件的内容
```bash
[15:54:15 root@ubuntu2004 ~]#cat ~/.ssh/known_hosts

|1|OpjgnTxpP8LHAjTu3gz93n1TvV8=|irXbm35oon22yJIxXcZBNjF4Qt8= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGONFbM8g/uU8//Xwk4gCFdyu8ym7g5dc3sNHVzLttlHxx7mA80C9jP3jkKl+F5p/DHZC3OZzk4wDR1bii13RjU=
```

`known_hosts` 文件的内容组成如下：
- Hostname or IP address of the remote host.
如上面的 `|1|OpjgnTxpP8LHAjTu3gz93n1TvV8=|irXbm35oon22yJIxXcZBNjF4Qt8=`
该字段的格式为 `|1|<BASE64_DATA_HERE>|<HOSTNAME>`，即 `hashed known_hosts format`

- Public key type (e.g. ssh-rsa, ssh-ed25519).
第二字段和服务端公钥文件的内容的第一字段相同
```bash
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGONFbM8g/uU8//Xwk4gCFdyu8ym7g5dc3sNHVzLttlHxx7mA80C9jP3jkKl+F5p/DHZC3OZzk4wDR1bii13RjU=
```

- Public key data (encoded in base64).
第三字段和服务端公钥文件的内容的第二字段相同
```bash
AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGONFbM8g/uU8//Xwk4gCFdyu8ym7g5dc3sNHVzLttlHxx7mA80C9jP3jkKl+F5p/DHZC3OZzk4wDR1bii13RjU=
```

- Comment (optional).
最后的注释部分有时有，有时没有，原来的公钥文件 `ssh_host_ecdsa_key.pub`中有注释
```bash
[16:15:18 root@ubuntu2004 /etc/ssh]#cat ssh_host_ecdsa_key.pub
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGONFbM8g/uU8//Xwk4gCFdyu8ym7g5dc3sNHVzLttlHxx7mA80C9jP3jkKl+F5p/DHZC3OZzk4wDR1bii13RjU= root@cdqz-KPL-W0X
```

## SSH_MSG_USERAUTH_REQUEST 服务端验证客户端
在客户端确认了服务端的指纹，获取了服务端的 host public key 后，
需要服务端输入连接客户端的密码（如果是用户密码验证）

### password authentication 密码验证
客户端发送 SSH_MSG_USERAUTH_REQUEST 消息给服务端，包含客户端的用户名，
向验证的方式等
服务端收到客户端的消息提醒客户端输入密码
客户端输入密码后发给服务端
服务端验证用户密码

整个过程被加密，可能时利用 key exchange 时得到的对称密钥（session key, shared secret key），
或非堆成加密方式，即服务端的公钥加密


# SSH communication
> [[Ultimate Guide] How SSH works?](https://www.thegeekyway.com/ultimate-guide-how-ssh-works/)

在 SSH handshake 以后，双方通信通常是采用对称加密方式，用 key exchange 过程中生成的 session key 加密

非对称加密（公钥加密）方式效率比对称加密更低

非对称加密通常在 SSH handshake 过程中认证双方身份时使用


## 安装 ssh 服务端

## 查看 ssh 配置文件
### Ubuntu 查看



