**网络安全基础学习**


# 信息安全防护目标
> [Information security](https://en.wikipedia.org/wiki/Information_security#Integrity)

Alice 要发送给信息给 Bob
1. 对于 Alice 来说要确保的有：
- 完整性（Integrity）：数据能完整的发送给 Bob，不丢失，不被篡改
- 保密性（Confidentiality）：数据发送的过程能保密，不被其他人看到
- 可控性（Controlablity）：对数据的传播和内容有控制能力
  如可以设置对方对数据的操作权限，不能超过权限使用
- 不可抵赖性（Non-repudiation）：用户无法否认其行为

1. 对于 Bob 来说，要确保的有：
- 真实性（Authenticity）：对数据来源进行判断，识别来源的信息
- 完整性（Integrity）：确保数据未被修改
- 可用性（Usability）：可以合法的使用数据，不会被拒绝
- 不可抵赖性（Non-repudiation）：Alice 无法否认其行为


# 安全防护环节
## 物理安全（Physical security）
- 机房设备环境

## 系统安全（System security）
- 操作系统

## 应用安全（Application security）
- 网络服务
- 应用程序

## 网络安全（Network security）
- 网络访问控制，防火墙规则设置

## 数据安全（Data security）
- 数据加密
- 数据备份

## 管理安全（Manage security）
- 保障性规范


# 常见的安全攻击
> [STRIDE (security)](https://en.wikipedia.org/wiki/STRIDE_(security))


# 常用的安全技术
## 认证（Authentication）
> [What is Authentication? Different Types of Authentication](https://blog.miniorange.com/different-types-of-authentication-methods-for-security/)

1. Password-based authentication
2. Biometric authentication
3. Multi-factor authentication
4. Certificate-based authentication
5. Token-based authentication
6. Kerberos authentication
7. Single Sign-On (SSO)
8. SAML-based authentication
9. OpenID-based authentication
10. OAuth-based authentication

- Authentication 决定用户是否能访问某个资源

## 授权（Authorization）
> [Authentication vs. Authorization](https://www.okta.com/identity-101/authentication-vs-authorization/)


- Authorization 决定用户访问资源时具有哪些权限，如可能只读，或者部分文件不能访问等

## 审计（Audit）
> [What Is a Security Audit? The Basics You Need to Get Started](https://www.auditboard.com/blog/what-is-security-audit/)


## 安全通信（Secure communication）
> [Secure communication](https://en.wikipedia.org/wiki/Secure_communication)



# 加密算法（Encrption algorithm）
> [5 Common Encryption Algorithms and the Unbreakables of the Future](https://www.arcserve.com/blog/5-common-encryption-algorithms-and-unbreakables-future)


- 传统的加密方法，例如 Alice 和 Bob 约定使用某一本书的内容加密，第几页的第几行的第几列，三个数字找到一个字符

## 对称加密算法
> [Symmetric key alogrithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm)

- Alice 和 Bob 使用一个双方都知道的密钥加密数据

常见的有：
- DES
- 3DES
- IDEA
- AES
- RC4

  
优点：
- 加密和解密密钥相同，效率高
  
缺点：
- 发送方很难安全传输密钥：计算机通信中，如需临时进行一次通信，怎么能安全的将密钥告诉对方？
- 接收方无法确认来源：一方收到密钥后怎么确认来源的可靠性，如果是中间人伪造的密钥呢？


## 非对称加密算法
> [Public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)

- 也叫公钥加密算法
- 利用一对密钥进行加密和解密
- 密钥成对出现，有公钥（public key）和私钥（secret key）
- 公钥加密的数据只有对应的私钥能解密
- 私钥要保密，只有自己持有，公钥可以公开
- Alice 用 Bob 的公钥加密数据，只有 Bob 能用自己的私钥解密，即使数据被截获也无法看到内容


特点：
- 如果确定了对方的公钥没问题，可以保证数据安全性，对方公钥加密的数据只有对方私钥能解密


不足：
- 算法复杂，不适合加密大数据，效率低，适合加密较小的数据
- 可能遇到中间人攻击（(Man-in-the-middle attack)[https://en.wikipedia.org/wiki/Man-in-the-middle_attack] ）
如有中间人冒充 Bob 发给 Alice 自己的公钥，获取从 Alice 得到的数据后可以用自己的私钥解密
根本原因是 Alice 无法确认收到的公钥是否真的是 Bob 的


常见算法：
- RSA
- [Digital Signature Algorithm (DSA)](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm)
- [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)
比 RSA 使用更小的密钥，更高的安全性
- [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) 
- [ED25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519)

## 单向哈希算法
> [Cryptographic hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
> [Hash function](https://en.wikipedia.org/wiki/Hash_function)

- h=hash(m)
- one-way function，单向性，不能根据最终的哈希值 h，得到原始的数据的内容
- 大多数是任意长度输入（m），固定长度输出（h）
- 两组不同的数据 m1 和 m2，即使内容相差很小，其得到的哈希值相差很大，即雪崩效应
- 相同的数据得到的哈希值相同
- 哈希运算的结果叫 message digest，即消息摘要
- 信息安全中使用的哈希函数是加密的哈希函数（cryptographic hash function），非普通的哈希函数




### 应用场景
- 确认数据的完整性
根据哈希算法的特点，可以传输时用某个哈希算法对数据内容做哈希运算得到一个摘要（message digest），
接收方收到数据后，用相同的哈希算法对数据做哈希运算，如果得到的摘要和发送方的摘要相同，则表示数据未被篡改

如下载某个软件时，官方提供安装包和 checksum 文件，该 checksum 文件中即为该文件的摘要，
用户下载文件后用官方指定的哈希算法对文件进行哈希运算，如果得到的摘要信息相同，则表示文件未被修改

如下载 [MySQL](https://dev.mysql.com/downloads/repo/apt/)，官方提供的软件包的摘要和算法如下：
```
MD5: 3f16076cf125a07675eb5f9ef080f1f7 
```
因此下载该包后可以用 MD5 哈希算法对文件进行哈希运算，得到的摘要和官方提供的相同则文件没问题

![](img/2023-05-20-11-32-29.png)


### 常用的哈希算法有
> [Secure Hash Algorithms](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms)

- MD5
message-digest algorithm，很常用，很多软件用 MD5 算法来得到一个 checksum 来验证数据的 Integrity
该算法已经被验证不安全，因此只能用于一些非加密的目的使用
- SHA-256
属于 Secure Hash Algorithm 2，其摘要的长度为 256 bits
- SHA-512
属于 Secure Hash Algorithm 2，其摘要的长度为 512 bits


# 指纹（Fingerprint）
> [Fingerprint (computing)](https://en.wikipedia.org/wiki/Fingerprint_(computing)) 

根据维基百科中的说法，指纹和哈希算法得到摘要的原理类似，指纹函数可以看作高性能的哈希函数
指纹函数也是可以将数据运算后得到唯一的指纹，该指纹字符串很短，特点和摘要很像
可以用于跟踪一个文件是否被修改过等，指纹字符很短，很多场景使用比哈希运算更适合

上述说法是否准确不确定，有些地方将指纹和哈希看作相同的，
[Hash function](https://en.wikipedia.org/wiki/Hash_function) 中指明两者有区别，但未说明具体区别


# 数字签名
> [What are digital signatures?](https://www.docusign.com/how-it-works/electronic-signature/digital-signature/digital-signature-faq)
> [Digital signature](https://en.wikipedia.org/wiki/Digital_signature)

- 数字签名可以让接受数据一方确认数据的完整性和来源
- 数字签名不对数据加密
- 例如某个官方提供一个软件包，用户下载该软件包时可以利用数字签名确保文件未被篡改，来源可靠
如下载 [MySQL](https://dev.mysql.com/downloads/repo/apt/)，官方提供的软件包的摘要和算法如下：
官方提供数字签名验证方法：[2.1.4.2 Signature Checking Using GnuPG](https://dev.mysql.com/doc/refman/8.0/en/checking-gpg-signature.html) 


数字签名过程：
- 发送方
1. 将数据用哈希算法计算得到一个摘要（message digest）
2. 将得到的摘要用自己的私钥加密
3. 要传输的数据 + 加密的摘要 ==> 数字签名的文档（digital singed document）

- 接收方
1. 用发送方的公钥解密被加密的摘要，得到原始数据的摘要
2. 用相同的哈希算法对收到的数据计算得到一个收到数据的摘要
3. 比对解密后的摘要和自己计算的摘要，如相同，则表示数据未被篡改


特点：
1. 哈希算法对比摘要保证数据的完整性
2. 公私钥匙加密解密确认来源
   

不足：
1. 接受方需要通过可靠的方式确保公钥是加密方的公钥而非中间人的公钥


# CA 颁发证书
> [Issuing a certificate](https://en.wikipedia.org/wiki/Certificate_authority#Issuing_a_certificate)

数字签名有个问题是无法确认公钥的可靠性，因此需要一个权威的机构来认证，让用户相信公钥的可靠性

CA（Certificate authority）是权威的颁发数字证书的机构
Windows 系统上内置受信任的根证书颁发机构，这些权威机构的公钥和所用的签名算法是公开的
根 CA 下还有很多下级 CA，申请数字证书时可能从某一级 CA 申请颁发，该证书中会带有其上级 CA 的证书，
直到根 CA 证书，一级一级验证


## 向 CA 机构申请证书的过程
> [X.509](https://en.wikipedia.org/wiki/X.509#Structure_of_a_certificate)
> [Public key certificate](https://en.wikipedia.org/wiki/Public_key_certificate)


1. 向 CA 机构提供自己的信息：自己的机构名等信息（类似办理身份证），自己的公钥以及公钥算法
2. CA 机构验证提交的信息后，加上颁发机构信息，证书的有效期，对该证书要使用的哈希算法和签名算法
3. 上面内容组成数字证书的 body 部分，该内容不加密，公开的

4. CA 利用证书中写明的哈希算法对 body 部分做哈希运算，得到该内容的摘要（message digest）
5. CA 利用证书中写明的签名算法对上面得到的摘要进行数字签名，即用自己的私钥用签名算法对摘要加密

6. 如果 CA 颁发机构不是根证书颁发机构，该证书中还要携带其上级 CA 给自己颁发的证书，
以及上级证书的证书，直到最上面的根 CA 的颁发证书，而根 CA 的证书是操作系统中自带的



## CA 颁发的证书内容
> [4. Certificate and Certificate Extensions Profile](https://www.rfc-editor.org/rfc/rfc5280#section-4)

X.509 v3 certificate 有三部分
```
Certificate  ::=  SEQUENCE  {
        tbsCertificate       TBSCertificate,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  }
```
1. TBSCertificate
即 To-Be-Signed Certificate，需要签名的证书 body 部分，该部分内容公开，需要进行数字签名

- serial number
证书的一个序列号，唯一标识

- subject
证书持有者的信息，组织名，地址等，如
```
CN = *.wikipedia.org
O = Wikimedia Foundation, Inc.
L = San Francisco
ST = California
C = US
```

- issuer
颁发证书单位的信息，如：
```
CN = DigiCert TLS Hybrid ECC SHA384 2020 CA1
O = DigiCert Inc
C = US
```

- validity
证书的有效期，包括 not before 和 not after 两个时间，即证书起始和失效时间

- Subject Public Key Info
证书持有者的公钥信息
  - Public Key Algorithm
  公钥解密时所用是算法，即非对称加密算法，如：
  ```
  Elliptic Curve Public Key
  ```
  - Subject Public Key
  证书持有者的公钥

- AlgorithmIdentifier
和 Certificate Signature Algorithm 内容要相同

- Extensions (optional)
可有可无的一段


2. Certificate Signature Algorithm
证书签名算法，包含两个算法
一个是 CA 对证书内容（body）部分利用哈希算法进行运算得到一个摘要的算法
一个是 CA 对上面摘要进行数字签名（公私钥非对称加密解密算法），即 CA 用自己的私钥加密
如下面内容表示证书的内容用 SHA-384 哈希算法运算，再将得到的摘要用 ECDSA 算法进行签名
```
X9.62 ECDSA Signature with SHA-384
```

3. Certificate Signature Value
证书数字签名的结果，该部分不是证书 body 的部分，证书的 body 部分未加密，公开的
用户根据证书的内容知道证书数字签名的算法，利用相同算法和 CA 的公钥对数字签名的值解密
得到摘要信息，再根据证书的内容，用相同的哈希算法对证书内容进行哈希运算
最好比对哈希运算的结果和数字签名解密后的结果（哈希运算不可逆）



## 浏览器中查看网站的证书
用 google chrome 进入如维基百科网页时，点击网页 url 左侧的小锁，查看证书时发现最后有个指纹信息，
![](img/2023-05-29-21-05-34.png)


证书本身没有最后的指纹的，该指纹根据网上的说法，是对整个证书做了一个哈希运算，
将证书导出成 .crt 的文件后用命令来查看证书无最后的指纹部分
```bash
openssl x509 -in _.wikipedia.org.crt -text -noout
```


## 用户验证数字证书的过程
1. 用户根据证书的 body 部分得知数字签名的算法，用相同的算法和 CA 的公钥解密签名数值，得到摘要信息
2. 根据证书 body 部分的哈希算法，用相同的算法对 body 进行哈希运算，得到一个摘要值
3. 比对自己计算得到的摘要和数字签名解密后得到的摘要值，相同则证书可信

## 证书文件名后缀
> [Certificate filename extensions](https://en.wikipedia.org/wiki/X.509#Certificate_filename_extensions)

> .pem – (Privacy-enhanced Electronic Mail) Base64 encoded DER certificate, 
> enclosed between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----
>
> .cer, .crt, .der – usually in binary DER form, but Base64-encoded certificates are common too (see .pem above)
>
> .p7b, .p7c – PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)
>
> .p12 – PKCS#12, may contain certificate(s) (public) and private keys (password protected)
>
> .pfx – PFX, predecessor of PKCS#12 (usually contains data in PKCS#12 format, e.g., with PFX files generated in IIS)


> [Difference between pem, crt, key files](https://stackoverflow.com/questions/63195304/difference-between-pem-crt-key-files)
> [ PKIX Textual Encodings](https://www.rfc-editor.org/rfc/rfc7468)


- 一般证书文件名字后缀为 `.cert` 或 `.crt`
- `.csr` 指 `certificate signing request`，如生成自签名证书时提交的证书申请文件使用的后缀
- `.pem` Privacy Enhanced MailBase64，编码的证书，通常为公钥文件
- `.key` 通常为私钥文件


# 多种算法综合运用
- Alice 发送数据给 Bob
## Pb{Sa[hash(data)]+data}
1. Alice 将数据用哈希算法加密得到摘要
2. Alice 将摘要用自己的私钥加密进行数字签名
3. Alice 将数字签名和数据用 Bob 的公钥加密

## key{Sa[hash(data)]+data}+Pb(key)
1. Alice 将数据用哈希算法加密得到摘要
2. Alice 将摘要和数据一起用自己的私钥加密
3. Alice 用一个对称的密钥加密第二部的数据得到密文
4. Alice 用 Bob 的公钥加密第三步的对称密钥


# IKE 互联网密钥交换协议
> [IKE](https://en.wikipedia.org/wiki/Internet_Key_Exchange#IKEv1_phases)

> In computing, Internet Key Exchange (IKE, sometimes IKEv1 or IKEv2, depending on version)
> is the protocol used to set up a security association (SA) in the IPsec protocol suite.


## Diffie–Hellman key exchange 
> [Diffie–Hellman key exchange](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange)


- 通信双方在公共信道中安全交换密钥的一种安全方法

> In the Diffie–Hellman key exchange scheme, each party generates a public/private key pair
> and distributes the public key. 
> After obtaining an authentic copy of each other's public keys, 
> Alice and Bob can compute a shared secret offline. 
> The shared secret can be used, for instance, as the key for a symmetric cipher.


# PKI 公共密钥加密体系
> [Public key infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure)

> A public key infrastructure (PKI) is a set of roles, policies, hardware, 
> software and procedures needed to create, manage, distribute, use, 
> store and revoke digital certificates and manage public-key encryption. 


# 安全协议 SSL/TLS
> [What is an SSL Certificate?](https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https)
> [What is SSL?](https://www.ssl.com/faqs/faq-what-is-ssl/)

- SSL 和 TLS 都是安全协议，保证数据在网络中安全传输
- TLS 是 SSL 的升级，当前主要用 TLS
- TLS 协议在应用层和运输层之间位置

原来的 http 是不安全的明文传输协议，后来的 https 即为 http 和 TLS 的组合，对数据加密，更安全



# Base64 编码
> [Base64](https://en.wikipedia.org/wiki/Base64)
> [What is Base64?](https://base64.guru/learn/what-is-base64)

> In computer programming, Base64 is a group of binary-to-text encoding schemes 
> that represent binary data (more specifically, a sequence of 8-bit bytes) 
> in sequences of 24 bits that can be represented by four 6-bit Base64 digits.

- Base64 是一种编码方式，将 8 bit 字节的二进制数据转换为可打印字符的编码方法
- Base64 不是加密算法，是可以破解的，用来将二进制数据显示为可打印的文本字符
- Base64 常用于邮件中传输二进制文件，以及证书中使用等，有些邮件系统仅支持 ASCII 文本
- CA 证书文件，公私钥文件等使用的是 Base64 编码


# Openssl
> [OpenSSL](https://www.openssl.org/)

- OpenSSL 是一个开源的用于加密和安全通信的软件包
  

## openssl 命令行工具

### 三种命令
输入 `openssl` 回车相当于 `openssl help`，可看见命令说明，
共有三种命令：
- standard commands
- Message Digest commands 
- Cipher commands

```bash
[root@ubuntu22 ~]$ openssl
help:

Standard commands
asn1parse         ca                ciphers           cmp
cms               crl               crl2pkcs7         dgst
dhparam           dsa               dsaparam          ec
ecparam           enc               engine            errstr
fipsinstall       gendsa            genpkey           genrsa
help              info              kdf               list
mac               nseq              ocsp              passwd
pkcs12            pkcs7             pkcs8             pkey
pkeyparam         pkeyutl           prime             rand
rehash            req               rsa               rsautl
s_client          s_server          s_time            sess_id
smime             speed             spkac             srp
storeutl          ts                verify            version
x509

Message Digest commands (see the `dgst' command for more details)
blake2b512        blake2s256        md4               md5
rmd160            sha1              sha224            sha256
sha3-224          sha3-256          sha3-384          sha3-512
sha384            sha512            sha512-224        sha512-256
shake128          shake256          sm3

Cipher commands (see the `enc' command for more details)
aes-128-cbc       aes-128-ecb       aes-192-cbc       aes-192-ecb
aes-256-cbc       aes-256-ecb       aria-128-cbc      aria-128-cfb
aria-128-cfb1     aria-128-cfb8     aria-128-ctr      aria-128-ecb
aria-128-ofb      aria-192-cbc      aria-192-cfb      aria-192-cfb1
aria-192-cfb8     aria-192-ctr      aria-192-ecb      aria-192-ofb
aria-256-cbc      aria-256-cfb      aria-256-cfb1     aria-256-cfb8
aria-256-ctr      aria-256-ecb      aria-256-ofb      base64
bf                bf-cbc            bf-cfb            bf-ecb
bf-ofb            camellia-128-cbc  camellia-128-ecb  camellia-192-cbc
camellia-192-ecb  camellia-256-cbc  camellia-256-ecb  cast
cast-cbc          cast5-cbc         cast5-cfb         cast5-ecb
cast5-ofb         des               des-cbc           des-cfb
des-ecb           des-ede           des-ede-cbc       des-ede-cfb
des-ede-ofb       des-ede3          des-ede3-cbc      des-ede3-cfb
des-ede3-ofb      des-ofb           des3              desx
rc2               rc2-40-cbc        rc2-64-cbc        rc2-cbc
rc2-cfb           rc2-ecb           rc2-ofb           rc4
rc4-40            seed              seed-cbc          seed-cfb
seed-ecb          seed-ofb          sm4-cbc           sm4-cfb
sm4-ctr           sm4-ecb           sm4-ofb
```

### openssl 语法

openssl 语法格式：
> openssl command [ options ... ] [ parameters ... ]

openssl 查看三种命令和算法：
> openssl list standard-commands | digest-commands | cipher-commands | cipher-algorithms 
> | digest-algorithms | mac-algorithms | public-key-algorithms


> openssl no-XXX [ options ]

### openssl 单项哈希算法加密

#### 查看摘要命令和摘要算法
```bash
[root@ubuntu22 ~]$ openssl list -digest-commands
blake2b512        blake2s256        md5               sha1
sha224            sha256            sha3-224          sha3-256
sha3-384          sha3-512          sha384            sha512
sha512-224        sha512-256        shake128          shake256
sm3
```

```bash
[root@ubuntu22 ~]$ openssl list -digest-algorithms | head -n15
Legacy:
  RSA-MD4 => MD4
  RSA-MD5 => MD5
  RSA-RIPEMD160 => RIPEMD160
  RSA-SHA1 => SHA1
  RSA-SHA1-2 => RSA-SHA1
  RSA-SHA224 => SHA224
  RSA-SHA256 => SHA256
  RSA-SHA3-224 => SHA3-224
  RSA-SHA3-256 => SHA3-256
  RSA-SHA3-384 => SHA3-384
  RSA-SHA3-512 => SHA3-512
  RSA-SHA384 => SHA384
  RSA-SHA512 => SHA512
  RSA-SHA512/224 => SHA512-224
```


几种不同写法：

如用 md5 算法对文件加密，可以用 `openssl md5` 或者 `openssl dgst -md5`，
或者用 `md5sum` 工具加密，得到的结果相同

```bash
[root@ubuntu22 ~]$ whatis md5sum
md5sum (1)           - compute and check MD5 message digest
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl md5 /etc/passwd
MD5(/etc/passwd)= 8198e91069df077218a4c0f001d81653
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl dgst -md5 /etc/passwd
MD5(/etc/passwd)= 8198e91069df077218a4c0f001d81653
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ md5sum /etc/passwd
8198e91069df077218a4c0f001d81653  /etc/passwd
```

用 `openssl dgst` 时不指定加密算法，则默认为 `sha256`
```bash
[root@ubuntu22 ~]]$ openssl dgst /etc/passwd
SHA256(/etc/passwd)= dfcb0be8c072dacdb3434106fa61d00911c34d282f7490b1b93d1e70de8d6d79
```

### openssl passwd 生成用户密码
`openssl passwd --help` 查看帮助，列出不同分类的选项
`man openssl passwd` 查看更详细的帮助

不加任何参数加密相同的数结果不同
```bash
[root@ubuntu22 ~]$ openssl passwd 123
$1$B2FtRHhm$1iT1HdlXBF8Ug/UTwAeYi/
[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl passwd 123
$1$igbevHLN$mFSXe43py6RacnAU0MFAQ1
```

- 上面加密后的内容由三部分组成，由 `$` 分隔
- 第一部分为加密算法，默认为 `1`，代表 md5，`5` 表示 sha256，`6` 表示 `sha512`
- 第二部分为盐值，同样的数据，算法相同，但 salt 不同，得到的密文不同
- 第三部分为利用前面的加密算法和盐值计算出来的密文
可以指定相同的盐值和算法，这样相同的内容得到的密文也相同：
```bash
[root@ubuntu22 ~]$ openssl passwd -1 -salt "igbevHLN"
Password:
$1$igbevHLN$mFSXe43py6RacnAU0MFAQ1
[root@ubuntu22 ~]$ openssl passwd -1 -salt "igbevHLN" 123
$1$igbevHLN$mFSXe43py6RacnAU0MFAQ1
```

### openssl rand 生成随机数
```bash
[root@ubuntu22 ~]$ openssl rand --help
Usage: rand [options] num

General options:
 -help               Display this summary
 -engine val         Use engine, possibly a hardware device

Output options:
 -out outfile        Output file
 -base64             Base64 encode output
 -hex                Hex encode output

Random state options:
 -rand val           Load the given file(s) into the random number generator
 -writerand outfile  Write random data to the specified file

Provider options:
 -provider-path val  Provider load path (must be before 'provider' argument if required)
 -provider val       Provider to load (can be specified multiple times)
 -propquery val      Property query used when fetching algorithms

Parameters:
 num                 Number of bytes to generate
```

- 不指定编码，则显示的字符可能乱码或不可打印字符等
base64 编码用 6 位来组成一个新的字节，因此指定随机数 3 字节，则生成的字符有 4 个
```bash
[root@ubuntu22 ~]$ openssl rand 3
kC⚌[root@ubuntu22 ~]$
[root@ubuntu22 ~]$ openssl rand -base64 3
QptA
[root@ubuntu22 ~]$ openssl rand -hex 3
f9956f
```

- 其他随机数生成器，有 `/dev/random` 或 `/dev/urandom` 

#### 创建新用户并生成指定长度的随机密码






# ssh handshake
> [SSH Handshake Explained](https://goteleport.com/blog/ssh-handshake-explained/)
> [SSH Handshake](https://yabhinav.github.io/security/openssh-handshake-overview/)


1. SSH protocol version exchange
客户端和服务端双方交换 SSH 版本信息
不同的版本有些功能有差异，因此需要确认双方版本

2. Key Exchange Initialization

- 双方发送 `SSH_MSG_KEX_INIT` 消息协商使用的加密算法
  该消息中携带自己支持的加密算法列表，以及算法的优先级
  为了后面使用算法加密能达成一致，使用双方都支持的算法

3. Key Exchange 
交换密钥，如用 Elliptic Curve Diffie-Hellman (ECDH) 方法交换密钥

- 客户端生成一对临时的公私钥对，该密钥对仅在此次会话中短暂有效，不会存在文件中保存下来，因此更安全
- 客户端将其临时公钥发送给服务端，如发送 `SSH_MSG_KEX_ECDH_INIT` message
- 服务端监听 `SSH_MSG_KEX_ECDH_INIT` message，一旦接受到该消息，
  服务端也生成一对临时的公私钥对，
  服务端利用客户端的公钥和自己的生成的临时的密钥对生成一个共享的密钥 `k`（该过程通过 Diffie-Hellman 算法得到）,生成的该共享密钥为对称密钥，用于后面的一些通信
- 




- 客户端第一次连接服务端时会显示服务端的指纹，指明了生成指纹所使用的公钥文件
以及加密算法，不同的客户端连接服务器时使用的算法可能不同

如服务端为 ubuntu20.04，其 `/etc/ssh` 目录中有几种不同算法的公钥：
```bash
[18:59:15 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```
- `rsa` 和  `ecdsa` 分别对应不同的密钥交换算法


客户端第一次连接，如 rocky8 连接，会提示指纹信息：
```bash
[root@rocky8-3 .ssh]$ ssh 192.168.137.17
The authenticity of host '192.168.137.17 (192.168.137.17)' can't be established.
ECDSA key fingerprint is SHA256:iBJIDP0FkveLmB549s75m3T7qfYU4nuNUKLeJqwRj2M.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
从提示可以看出使用的公钥为 `ssh_host_ecdsa_key.pub`，对该公钥进行数字前面的单项哈希算法为 `SHA256`

而客户端 ubuntu22.04 来连接服务器时，提示为：
```bash
[root@ubunut22:~]$ ssh  192.168.137.17
The authenticity of host '192.168.137.17 (192.168.137.17)' can't be established.
ED25519 key fingerprint is SHA256:gLez30G4gynTfEWJe7kvn3I0w5x8a18+/wvDQorzCEk.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
从提示可以看出使用的公钥为 `ssh_host_ed25519_key.pub`，对该公钥进行数字前面的单项哈希算法为 `SHA256`
因此两者的指纹不同

- 验证指纹是否正确
此时客户端需要确认指纹是否正确从而确认服务端的是相连接的服务端而非其他中间人
服务端可以在自己主机上查看生成的指纹，从而进行比对（单项哈希算法生成的指纹不可逆的）

1）服务端可以通过连自己查看指纹，但这里默认的公钥文件为 `ssh_host_ecdsa_key.pub`
```bash
[19:23:41 root@ubuntu2004 /etc/ssh]#ssh 127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:iB
```

```bash
[19:34:49 root@ubuntu2004 /etc/ssh]#ls
moduli        sshd_config         ssh_host_ecdsa_key.pub    ssh_host_rsa_key
ssh_config    sshd_config.d       ssh_host_ed25519_key      ssh_host_rsa_key.pub
ssh_config.d  ssh_host_ecdsa_key  ssh_host_ed25519_key.pub  ssh_import_id
```

2）通过 ssh-keygen 生成指纹进行比对
`ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]`
`-l` 表示显示公钥文件的指纹
`-E` 显示用于数字签名的单向哈希算法，可选的有 `sha256` 和 `md5`，默认为 `sha256`
`-f` 指定公钥文件

```bash
[19:37:06 root@ubuntu2004 /etc/ssh]#ssh-keygen -l -E "sha256" -f ssh_host_ed25519_key.pub
256 SHA256:gLez30G4gynTfEWJe7kvn3I0w5x8a18+/wvDQorzCEk root@cdqz-KPL-W0X (ED25519)
```

- 客户端确认指纹后输入 `yes` 则将服务端的公钥文件，如 `ssh_host_ed25519_key.pub` 
  下载到自己家目录的 `$HOME/.ssh/known_hosts` 文件中，以后再次连接时就不需要确认指纹 


如果不想输入 yes 来确认指纹，修改客户端配置文件


```
The reason you cannot use `sha256sum` to calculate the fingerprint of `ssh_host_ed25519_key.pub` is that the fingerprint is not simply a hash of the public key file. It is actually a specific representation of the public key that includes a hash of the key and some other metadata.

The fingerprint of an SSH public key is calculated using a specific algorithm that takes into account the type of key, the hash algorithm used to generate the key, and the actual public key data. For example, the fingerprint of an Ed25519 public key is calculated using the SHA-256 hash algorithm, but it includes additional information such as the key type and length.

To calculate the fingerprint of an SSH public key, you should use a tool that is specifically designed for this purpose, such as `ssh-keygen` or `openssl`. These tools will generate the correct representation of the public key and calculate the fingerprint using the appropriate algorithm.
```




## 安装 ssh 服务端

## 查看 ssh 配置文件
### Ubuntu 查看



